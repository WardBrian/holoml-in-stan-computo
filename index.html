<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brian Ward">
<meta name="author" content="Bob Carpenter">
<meta name="author" content="David Barmherzig">
<meta name="dcterms.date" content="2024-02-29">
<meta name="keywords" content="stan, coherent-diffraction-imaging, statistics">
<meta name="description" content="This case study is a reimplementation of the algorithm described in (David A. Barmherzig and Sun 2022) as a Stan model. This showcases some new features of Stan, available starting in version 2.30">

<title>HoloML in Stan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="HoloML in Stan_files/libs/clipboard/clipboard.min.js"></script>
<script src="HoloML in Stan_files/libs/quarto-html/quarto.js"></script>
<script src="HoloML in Stan_files/libs/quarto-html/popper.min.js"></script>
<script src="HoloML in Stan_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="HoloML in Stan_files/libs/quarto-html/anchor.min.js"></script>
<link href="HoloML in Stan_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="HoloML in Stan_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="HoloML in Stan_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="HoloML in Stan_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="HoloML in Stan_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; HoloML in Stan</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">Low-photon Image Reconstruction using Bayesian Tools</p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>This case study is a reimplementation of the algorithm described in <span class="citation" data-cites="Barmherzig:22">(<a href="#ref-Barmherzig:22" role="doc-biblioref">David A. Barmherzig and Sun 2022</a>)</span> as a Stan model. This showcases some new features of Stan, available starting in version 2.30</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliation</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://brianward.dev/">Brian Ward</a> <a href="https://orcid.org/0000-0002-9841-3342" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/">
                  Flatiron Institute
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://bob-carpenter.github.io/">Bob Carpenter</a> <a href="https://orcid.org/0000-0002-2433-9688" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/">
                  Flatiron Institute
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://davidbar.org/">David Barmherzig</a> <a href="https://orcid.org/0000-0003-2466-981X" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/">
                  Flatiron Institute
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 29, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">February 29, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">stan, coherent-diffraction-imaging, statistics</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur posuere vestibulum facilisis. Aenean pretium orci augue, quis lobortis libero accumsan eu. Nam mollis lorem sit amet pellentesque ullamcorper. Curabitur lobortis libero eget malesuada vestibulum. Nam nec nibh massa. Pellentesque porttitor cursus tellus. Mauris urna erat, rhoncus sed faucibus sit amet, venenatis eu ipsum.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a>
  <ul class="collapse">
  <li><a href="#experimental-setup" id="toc-experimental-setup" class="nav-link" data-scroll-target="#experimental-setup"><span class="header-section-number">1.1</span> Experimental setup</a></li>
  </ul></li>
  <li><a href="#simulating-data" id="toc-simulating-data" class="nav-link" data-scroll-target="#simulating-data"><span class="header-section-number">2</span> Simulating Data</a>
  <ul class="collapse">
  <li><a href="#imports-and-helper-code" id="toc-imports-and-helper-code" class="nav-link" data-scroll-target="#imports-and-helper-code"><span class="header-section-number">2.1</span> Imports and helper code</a></li>
  <li><a href="#simulation-parameters" id="toc-simulation-parameters" class="nav-link" data-scroll-target="#simulation-parameters"><span class="header-section-number">2.2</span> Simulation parameters</a></li>
  </ul></li>
  <li><a href="#stan-model" id="toc-stan-model" class="nav-link" data-scroll-target="#stan-model"><span class="header-section-number">3</span> Stan Model</a>
  <ul class="collapse">
  <li><a href="#functions" id="toc-functions" class="nav-link" data-scroll-target="#functions"><span class="header-section-number">3.1</span> Functions</a></li>
  <li><a href="#model-inputs" id="toc-model-inputs" class="nav-link" data-scroll-target="#model-inputs"><span class="header-section-number">3.2</span> Model inputs</a></li>
  <li><a href="#additional-fixed-information" id="toc-additional-fixed-information" class="nav-link" data-scroll-target="#additional-fixed-information"><span class="header-section-number">3.3</span> Additional fixed information</a></li>
  <li><a href="#parameters" id="toc-parameters" class="nav-link" data-scroll-target="#parameters"><span class="header-section-number">3.4</span> Parameters</a></li>
  <li><a href="#model-code" id="toc-model-code" class="nav-link" data-scroll-target="#model-code"><span class="header-section-number">3.5</span> Model code</a>
  <ul class="collapse">
  <li><a href="#priors" id="toc-priors" class="nav-link" data-scroll-target="#priors"><span class="header-section-number">3.5.1</span> Priors</a></li>
  <li><a href="#likelihood" id="toc-likelihood" class="nav-link" data-scroll-target="#likelihood"><span class="header-section-number">3.5.2</span> Likelihood</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#optimization" id="toc-optimization" class="nav-link" data-scroll-target="#optimization"><span class="header-section-number">4</span> Optimization</a>
  <ul class="collapse">
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation"><span class="header-section-number">4.1</span> Data preparation</a></li>
  </ul></li>
  <li><a href="#varying-n_p" id="toc-varying-n_p" class="nav-link" data-scroll-target="#varying-n_p"><span class="header-section-number">5</span> Varying <span class="math inline">N_p</span></a>
  <ul class="collapse">
  <li><a href="#prior-tuning" id="toc-prior-tuning" class="nav-link" data-scroll-target="#prior-tuning"><span class="header-section-number">5.1</span> Prior tuning</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#appendicies" id="toc-appendicies" class="nav-link" data-scroll-target="#appendicies">Appendicies</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="HoloML-in-Stan.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>The HoloML technique is an approach to solving a specific kind of inverse problem inherent to imaging nanoscale specimens using X-ray diffraction.</p>
<p>To solve this problem in Stan, we first write down the forward scientific model given by Barmherzig and Sun, including the Poisson photon distribution and censored data inherent to the physical problem, and then find a solution via penalized maximum likelihood.</p>
<section id="experimental-setup" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="experimental-setup"><span class="header-section-number">1.1</span> Experimental setup</h2>
<p>In coherent diffraction imaging (CDI), a radiation source, typically an X-ray, is directed at a biomolecule or other specimen of interest, which causes diffraction. The resulting photon flux is measured by a far-field detector. The expected photon flux is approximately the squared magnitude of the Fourier transform of the electric field causing the diffraction. Inverting this to recover an image of the specimen is a problem usually known as <em>phase retrieval</em>. The phase retrieval problem is highly challenging and often lacks a unique solution <span class="citation" data-cites="Barnett_2020">(<a href="#ref-Barnett_2020" role="doc-biblioref">Barnett et al. 2020</a>)</span>.</p>
<p>Holographic coherent diffraction imaging (HCDI) is a variant in which the specimen is placed some distance away from a known reference object, and the data observed is the pattern of diffraction around both the specimen and the reference. The addition of a reference object provides additional constraints on this problem, and transforms it into a linear deconvolution problem which has a unique, closed-form solution in the idealized setting <span class="citation" data-cites="Barmherzig_2019">(<a href="#ref-Barmherzig_2019" role="doc-biblioref">David A. Barmherzig et al. 2019</a>)</span>.</p>
<p>The idealized version of HCDI is formulated as</p>
<ul>
<li>Given a reference <span class="math inline">R</span>, data <span class="math inline">Y = | \mathcal{F}( X + R ) | ^2</span></li>
<li>Recover the source image <span class="math inline">X</span></li>
</ul>
<p>Where <span class="math inline">\mathcal{F}</span> is an oversampled Fourier transform operator.</p>
<p>However, the real-world set up of these experiments introduces two additional difficulties. Data is measured from a limited number of photons, where the number of photons received by each detector is modeled as Poisson distributed with expectation given by <span class="math inline">Y_{ij}</span> (referred to in the paper as <em>Poisson-shot noise</em>). The expected number of photons each detector receives is denoted <span class="math inline">N_p</span>. We typically have <span class="math inline">N_p &lt; 10</span> due to the damage that radiation causes the biomolecule under observation. Secondly, to prevent damage to the detectors, the lowest frequencies are removed by a <em>beamstop</em>, which censors low-frequency observations.</p>
<p>The maximum likelihood estimation of the model presented here is able to recover reasonable images even under a regime featuring low photon counts and a beamstop.</p>
</section>
</section>
<section id="simulating-data" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Simulating Data</h1>
<p>We simulate data from the generative model directly. This corresponds to the approach taken by Barmherzig and Sun, and is based on MATLAB code provided by Barmherzig.</p>
<section id="imports-and-helper-code" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="imports-and-helper-code"><span class="header-section-number">2.1</span> Imports and helper code</h2>
<p>Generating the data requires a few standard Python numerical libraries such as scipy and numpy. Matplotlib is also used to simplify loading in the source image and displaying results.</p>
<div id="97745f34" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmdstanpy</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.image <span class="im">as</span> mpimg</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rgb2gray(rgb):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert a nxmx3 RGB array to a grayscale nxm array.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">    This function uses the same internal coefficients as MATLAB:</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">    https://www.mathworks.com/help/matlab/ref/rgb2gray.html</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    r, g, b <span class="op">=</span> rgb[:, :, <span class="dv">0</span>], rgb[:, :, <span class="dv">1</span>], rgb[:, :, <span class="dv">2</span>]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    gray <span class="op">=</span> <span class="fl">0.2989</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.5870</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.1140</span> <span class="op">*</span> b</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gray</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="simulation-parameters" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="simulation-parameters"><span class="header-section-number">2.2</span> Simulation parameters</h2>
<p>To match the figures in the paper (in particular, Figure 9), we use an image of size 256x256, <span class="math inline">N_p = 1</span> (meaning each detector is expected to receive one photon), and a beamstop of size 25x25 (corresponding to a radius of 13), and a separation <code>d</code> equal to the size of the image.</p>
<div id="f52278dd" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> N</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>M1 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> N</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>M2 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> d)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can then load the source image used for these simulations. In this model, the pixels of <span class="math inline">X</span> grayscale values represented on the interval [0, 1]. A conversion is done here from the standard RGBA encoding using the above <code>rgb2gray</code> function.</p>
<p>The following is a picture of a <a href="https://en.wikipedia.org/wiki/Giant_virus">giant virus</a> known as a mimivirus.</p>
<p>Image credit: <a href="https://commons.wikimedia.org/wiki/File:Electron_microscopic_image_of_a_mimivirus_-_journal.ppat.1000087.g007_crop.png">Ghigo E, Kartenbeck J, Lien P, Pelkmans L, Capo C, Mege JL, Raoult D.</a>, <a href="https://creativecommons.org/licenses/by/2.5">CC BY 2.5</a>, via Wikimedia Commons</p>
<div id="f5b194fa" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>X_src <span class="op">=</span> rgb2gray(mpimg.imread(<span class="st">'mimivirus.png'</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_src, cmap<span class="op">=</span><span class="st">'gray'</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-5-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Additionally, we load in the pattern of the reference object.</p>
<p>The pattern used here is known as a <em>uniformly redundant array</em> (URA) <span class="citation" data-cites="Fenimore:78">(<a href="#ref-Fenimore:78" role="doc-biblioref">Fenimore and Cannon 1978</a>)</span>. It has been shown to be an optimal reference image for this kind of work, but other references (including none at all) could be used with the same Stan model.</p>
<p>The code used to generate this grid is omitted from this case study. Various options such as <a href="https://github.com/bpops/cappy">cappy</a> exist to generate these patterns in Python.</p>
<div id="5ad88bc7" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.loadtxt(<span class="st">'URA.csv'</span>, delimiter<span class="op">=</span><span class="st">","</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-6-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We create the specimen-reference hybrid image by concatenating the <span class="math inline">X</span> image, a matrix of zeros, and the reference <span class="math inline">R</span>. In the true experiment, this is done by placing the specimen some distance <code>d</code> away from the reference, with opaque material between.</p>
<p>This distance is typically the same as the size of the specimen, <code>N</code>. One contribution of the HoloML model is allowing recovery with the reference placed closer to the specimen, and the Stan model allows for this as well.</p>
<p>For this simulation we use the separation of <code>d = N</code>.</p>
<div id="f80f7441" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>X0R <span class="op">=</span> np.concatenate([X_src, np.zeros((N,d)), R], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(X0R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-8-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We can simulate the diffraction pattern of photons from the X-ray by taking the absolute value squared of the 2-dimensional oversampled FFT of this hybrid object.</p>
<p>The oversampled FFT (denoted <span class="math inline">\mathcal{F}</span> in the paper) corresponds to padding the image in both dimensions with zeros until it is a desired size. For our case, we define the size of the padded image, <code>M1</code> by <code>M2</code>, to be two times the size of our hybrid image, so the resulting FFT is twice oversampled. This is the oversampling ratio traditionally used for this problem, however Barmherzig and Sun also showed that this model can operate with less oversampling as well.</p>
<div id="9d195b3c" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.fft2(X0R, s<span class="op">=</span>(M1, M2))) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(np.log1p(Y)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-9-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We simulate the photon fluxes with a Poisson pseudorandom number generator.</p>
<p>This code specifies a fixed seed to ensure the same fake data is generated each time.</p>
<div id="2c3dc687" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>rate <span class="op">=</span> N_p <span class="op">/</span> Y.mean()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">=</span> stats.poisson.rvs(rate <span class="op">*</span> Y, random_state<span class="op">=</span><span class="dv">1234</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(np.log1p(Y_tilde)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-10-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Finally, we need to remove the low frequency content of the data. This is caused in the physical experiment by the inclusion of a beamstop, which protects the instrument used by preventing the strongest parts of the beam from directly shining on the detectors.</p>
<p>The beamstop is represented by <span class="math inline">\mathcal{B}</span>, a matrix of 0s and 1s. Zeros indicate that the data is occluded, while ones represent transparent portions.</p>
<div id="28b6f8cc" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>B_cal <span class="op">=</span> np.ones((M1,M2), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>B_cal[M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r, M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>B_cal <span class="op">=</span> np.fft.ifftshift(B_cal)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Sanity check</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (M1 <span class="op">*</span> M2 <span class="op">-</span> B_cal.<span class="bu">sum</span>()) <span class="op">==</span> (( <span class="dv">2</span> <span class="op">*</span> r <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(B_cal), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="fl">1.25</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-11-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We use this matrix <span class="math inline">\mathcal{B}</span> to mask the low frequencies of the simulated data. After removing these elements from the simulated data, we have the final input which is used in our model</p>
<div id="d39fff36" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">*=</span> B_cal</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(np.log1p(Y_tilde)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-12-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="stan-model" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Stan Model</h1>
<p>The Stan model code is a direct translation of the log density of the forward model described in the paper <span class="citation" data-cites="Barmherzig:22">(<a href="#ref-Barmherzig:22" role="doc-biblioref">David A. Barmherzig and Sun 2022</a>)</span> and above. The full model can be seen in the <a href="#full-code">appendix</a>.</p>
<section id="functions" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="functions"><span class="header-section-number">3.1</span> Functions</h2>
<p>We define two helper functions to implement this model in Stan. The first is a function responsible for generating the <span class="math inline">\mathcal{B}</span> matrix. Because Stan currently does not have FFT shifting functions, this is done by manually assigning to the corners of the matrix</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span> beamstop_gen(<span class="dt">int</span> M1, <span class="dt">int</span> M2, <span class="dt">int</span> r) {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">matrix</span>[M1, M2] B_cal = rep_matrix(<span class="dv">1</span>, M1, M2);</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// upper left</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    B_cal[<span class="dv">1</span> : r, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">0</span>, r, r);</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// upper right</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    B_cal[<span class="dv">1</span> : r, M2 - r + <span class="dv">2</span> : M2] = rep_matrix(<span class="dv">0</span>, r, r - <span class="dv">1</span>);</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lower left</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    B_cal[M1 - r + <span class="dv">2</span> : M1, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">0</span>, r - <span class="dv">1</span>, r);</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lower right</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    B_cal[M1 - r + <span class="dv">2</span> : M1, M2 - r + <span class="dv">2</span> : M2] = rep_matrix(<span class="dv">0</span>, r - <span class="dv">1</span>, r - <span class="dv">1</span>);</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_cal;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The FFT described in the paper is an oversampled FFT. This corresponds to embedding the image in a larger array of zeros and results in a sort of interpolation between frequencies in the result.</p>
<p>We write an overload of the <code>fft2</code> function which implements this behavior, similar to the signatures found in Matlab or Python libraries.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">complex_matrix</span> fft2(<span class="dt">complex_matrix</span> Z, <span class="dt">int</span> N, <span class="dt">int</span> M) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> r = rows(Z);</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c = cols(Z);</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">complex_matrix</span>[N, M] pad = rep_matrix(<span class="dv">0</span>, N, M);</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    pad[<span class="dv">1</span> : r, <span class="dv">1</span> : c] = Z;</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fft2(pad);</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>} <span class="co">// end functions block</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that while the first input of this function is a <code>complex_matrix</code>, it will also accept real matrices due to the built-in type promotion in Stan.</p>
</section>
<section id="model-inputs" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="model-inputs"><span class="header-section-number">3.2</span> Model inputs</h2>
<p>The Stan model needs the same information the generative model did, except it is supplied with <span class="math inline">\tilde{Y}</span> instead of the source image <span class="math inline">X</span>, plus a scale parameter for the prior, <span class="math inline">\sigma</span>. Smaller values of <span class="math inline">\sigma</span> (approaching 0) lead to increasing amounts of blur in the resulting image.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;                    <span class="co">// image dimension</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] R;  <span class="co">// reference image</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=N&gt; d;           <span class="co">// separation between sample and reference image</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=N&gt; M1;                   <span class="co">// rows of padded matrices</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span> * N + d&gt; M2;           <span class="co">// cols of padded matrices</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=M1&gt; r;          <span class="co">// beamstop radius. replaces omega1, omega2 in paper</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N_p;                  <span class="co">// avg number of photons per pixel</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; Y_tilde; <span class="co">// observed number of photons</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma;                <span class="co">// standard deviation of pixel prior.</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The constraints listed above, such as <code>lower=0</code>, perform input validation. For example, the size of the padded FFT is, at a minimum, the size of the hybrid <span class="math inline">X0R</span> specimen, and we are able to encode this in the model with the lower bounds on <code>M1</code> and <code>M2</code>.</p>
</section>
<section id="additional-fixed-information" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="additional-fixed-information"><span class="header-section-number">3.3</span> Additional fixed information</h2>
<p>Stan provides the ability to compute transformed data, values which depend on the inputs but only need to be evaluated once per model. This allows us to construct and store <span class="math inline">\mathcal{B}</span> once, without recomputing it each iteration or requiring it as input.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] B_cal = beamstop_gen(M1, M2, r);</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[d, N] separation = rep_matrix(<span class="dv">0</span>, d, N);</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="parameters" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="parameters"><span class="header-section-number">3.4</span> Parameters</h2>
<p>This model has only one parameter, the image <span class="math inline">X</span>. It is constrained to grayscale values between 0 and 1.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] X;</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-code" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="model-code"><span class="header-section-number">3.5</span> Model code</h2>
<section id="priors" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="priors"><span class="header-section-number">3.5.1</span> Priors</h3>
<p>We add a prior on <span class="math inline">X</span> to impose an L2 penalty on adjacent pixels. This induces a Gaussian blur on the result, and it is not strictly necessary for running the model.</p>
<p>This prior is coded in our Stan program by looping over the rows and columns and using a vectorized call to the <code>normal</code> distribution. This results in each pixel being adjacent to 4 others. One could also formulate a prior which includes diagonally adjacent pixels</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span> : rows(X) - <span class="dv">1</span>) {</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    X[i] ~ normal(X[i + <span class="dv">1</span>], sigma);</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span> : cols(X) - <span class="dv">1</span>) {</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    X[ : , j] ~ normal(X[ : , j + <span class="dv">1</span>], sigma);</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="likelihood" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="likelihood"><span class="header-section-number">3.5.2</span> Likelihood</h3>
<p>The model likelihood encodes the forward model. We construct the hybrid specimen, compute <span class="math inline">|\mathcal{F}(X0R)|^2</span>, and then compute the rate <span class="math inline">\lambda</span> by scaling by the average number of photons <span class="math inline">N_p</span>.</p>
<p>We then loop over this result. If the current indices are not occluded by the beamstop <span class="math inline">\mathcal{B}</span>, we say that the data <span class="math inline">\tilde{Y}</span> is distributed by a Poisson distribution with <span class="math inline">\lambda</span> as the rate parameter.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// object representing specimen and reference together</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, <span class="dv">2</span> * N + d] X0R = append_col(X, append_col(separation, R));</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// signal - squared magnitude of the (oversampled) FFT</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] Y = abs(fft2(X0R, M1, M2)) .^ <span class="dv">2</span>;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> N_p_over_Y_bar = N_p / mean(Y);</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] lambda = N_p_over_Y_bar * Y;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (m1 <span class="cf">in</span> <span class="dv">1</span> : M1) {</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (m2 <span class="cf">in</span> <span class="dv">1</span> : M2) {</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (B_cal[m1, m2] != <span class="dv">0</span>) {</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        Y_tilde[m1, m2] ~ poisson(lambda[m1, m2]);</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>} <span class="co">// end model block</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>
<section id="optimization" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Optimization</h1>
<p>Now that we have our simulated data and our generative model, we solve the inverse problem.</p>
<section id="data-preparation" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="data-preparation"><span class="header-section-number">4.1</span> Data preparation</h2>
<p>We prepare a dictionary of data corresponding to the models <code>data</code> block. This is mostly reusing constants defined earlier for the data simulation.</p>
<div id="b8cdcc4c" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span> <span class="co"># prior smoothing</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N"</span>: N,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"R"</span>: R,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"d"</span>: N,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"M1"</span>: M1,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"M2"</span>: M2,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Y_tilde"</span>: Y_tilde,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"r"</span>: r,</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N_p"</span>: N_p,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"sigma"</span>: sigma</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To run the model from Python, we instantiate it as a CmdStanModel object from cmdstanpy.</p>
<div id="0b213425" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>HoloML_model <span class="op">=</span> cmdstanpy.CmdStanModel(stan_file<span class="op">=</span><span class="st">"./holoml.stan"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>22:02:08 - cmdstanpy - INFO - compiling stan file /home/runner/work/holoml-in-stan-computo/holoml-in-stan-computo/holoml.stan to exe file /home/runner/work/holoml-in-stan-computo/holoml-in-stan-computo/holoml
22:02:35 - cmdstanpy - INFO - compiled model executable: /home/runner/work/holoml-in-stan-computo/holoml-in-stan-computo/holoml</code></pre>
</div>
</div>
<p>Here we use optimization via the limited-memory quasi-Newton L-BFGS algorithm. This method has a bit more curvature information than what is available to the conjugate gradient approach, but less than the second order trust-region method used in the paper. This should take a few (1-3) minutes, depending on the machine you are running on.</p>
<p>It is also possible to sample the model using the No-U-Turn Sampler (NUTS), but evaluations of this are out of the scope of this case study.</p>
<div id="257213d6" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit <span class="op">=</span> HoloML_model.optimize(data, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>22:02:36 - cmdstanpy - INFO - Chain [1] start processing
22:03:53 - cmdstanpy - INFO - Chain [1] done processing</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 626 ms, sys: 28.2 ms, total: 654 ms
Wall time: 1min 18s</code></pre>
</div>
</div>
<p>We use the function <code>stan_variable</code> to extract the maximum likelihood estimate (MLE) from the fit object returned by optimization.</p>
<p>We can use this to plot the recovered image alongside the original.</p>
<div id="7362f46e" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, title<span class="op">=</span><span class="st">"Source Image"</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>ax1.imshow(X_src, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, title<span class="op">=</span><span class="st">"Recovered Image"</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>ax2.imshow(fit.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-16-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="varying-n_p" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Varying <span class="math inline">N_p</span></h1>
<p>The above selection of <span class="math inline">N_p=1</span> is a reasonable choice for real experiment, but both smaller and larger numbers of expected photons may be used. The following are results for two other levels, <span class="math inline">N_p = 0.1</span> and <span class="math inline">N_p = 10</span></p>
<p>This requires repeating the final few steps of the data generation and then re-fitting the model accordingly.</p>
<div id="3f2fc83f" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">=</span> stats.poisson.rvs((N_p <span class="op">/</span> Y.mean()) <span class="op">*</span> Y, random_state<span class="op">=</span><span class="dv">1234</span>) <span class="op">*</span> B_cal</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>data_fewer_photons <span class="op">=</span> data.copy()</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>data_fewer_photons[<span class="st">'N_p'</span>] <span class="op">=</span> N_p</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>data_fewer_photons[<span class="st">'Y_tilde'</span>] <span class="op">=</span> Y_tilde</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_fewer_photons <span class="op">=</span> HoloML_model.optimize(data_fewer_photons, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>22:03:54 - cmdstanpy - INFO - Chain [1] start processing
22:05:18 - cmdstanpy - INFO - Chain [1] done processing</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 640 ms, sys: 8.54 ms, total: 649 ms
Wall time: 1min 24s</code></pre>
</div>
</div>
<div id="fee2cb00" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">=</span> stats.poisson.rvs((N_p <span class="op">/</span> Y.mean()) <span class="op">*</span> Y, random_state<span class="op">=</span><span class="dv">1234</span>) <span class="op">*</span> B_cal</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>data_more_photons <span class="op">=</span> data.copy()</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>data_more_photons[<span class="st">'N_p'</span>] <span class="op">=</span> N_p</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>data_more_photons[<span class="st">'Y_tilde'</span>] <span class="op">=</span> Y_tilde</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_more_photons <span class="op">=</span> HoloML_model.optimize(data_more_photons, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>22:05:19 - cmdstanpy - INFO - Chain [1] start processing
22:05:59 - cmdstanpy - INFO - Chain [1] done processing</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 629 ms, sys: 11.5 ms, total: 641 ms
Wall time: 40.9 s</code></pre>
</div>
</div>
<p>It is worth noting that these two optimizations take very different amounts of time compared to the original, as the differing amounts of data yield posteriors which are more or less normal.</p>
<p>In addition to the difference in runtime, the resulting images are very different.</p>
<div id="29e0e2ee" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, title<span class="op">=</span><span class="st">"Source Image"</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>ax1.imshow(X_src, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($N_p=10$)"</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>ax2.imshow(fit_more_photons.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>ax3 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($N_p=1$)"</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>ax3.imshow(fit.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>ax4 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($N_p=0.1$)"</span>)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>ax4.imshow(fit_fewer_photons.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-19-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="prior-tuning" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="prior-tuning"><span class="header-section-number">5.1</span> Prior tuning</h2>
<p>The above choice of <span class="math inline">\sigma = 1</span> has a very slight effect on the output image.</p>
<p>We also show the recovered image for <span class="math inline">\sigma = 20</span>, which provides even less smoothing than the above, and for <span class="math inline">\sigma = 0.05</span>. This smaller value imposes a greater penalty on adjacent pixels which are significantly different than each other, smoothing out the result.</p>
<p>Each of these is done with the original value of <span class="math inline">N_p = 1</span></p>
<div id="b7e553b8" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>data_weaker_prior <span class="op">=</span> data.copy()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>data_weaker_prior[<span class="st">'sigma'</span>] <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_rougher <span class="op">=</span> HoloML_model.optimize(data_weaker_prior, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>22:06:00 - cmdstanpy - INFO - Chain [1] start processing
22:07:28 - cmdstanpy - INFO - Chain [1] done processing</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 628 ms, sys: 19.8 ms, total: 647 ms
Wall time: 1min 28s</code></pre>
</div>
</div>
<div id="d5ed0a12" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>data_stronger_prior <span class="op">=</span> data.copy()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>data_stronger_prior[<span class="st">'sigma'</span>] <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_smooth <span class="op">=</span> HoloML_model.optimize(data_stronger_prior, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>22:07:29 - cmdstanpy - INFO - Chain [1] start processing
22:08:56 - cmdstanpy - INFO - Chain [1] done processing</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 635 ms, sys: 16.2 ms, total: 651 ms
Wall time: 1min 28s</code></pre>
</div>
</div>
<div id="7db5fda6" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, title<span class="op">=</span><span class="st">"Source Image"</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>ax1.imshow(X_src, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($\sigma=0.05$)"</span>)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>ax2.imshow(fit_smooth.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>ax3 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($\sigma=1$)"</span>)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>ax3.imshow(fit.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>ax4 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($\sigma=20$)"</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>ax4.imshow(fit_rougher.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HoloML%20in%20Stan_files/figure-html/cell-22-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Barmherzig:22" class="csl-entry" role="listitem">
Barmherzig, David A., and Ju Sun. 2022. <span>“Towards Practical Holographic Coherent Diffraction Imaging via Maximum Likelihood Estimation.”</span> <em>Opt. Express</em> 30 (5): 6886–906. <a href="https://doi.org/10.1364/OE.445015">https://doi.org/10.1364/OE.445015</a>.
</div>
<div id="ref-Barmherzig_2019" class="csl-entry" role="listitem">
Barmherzig, David A, Ju Sun, Po-Nan Li, T J Lane, and Emmanuel J Candès. 2019. <span>“Holographic Phase Retrieval and Reference Design.”</span> <em>Inverse Problems</em> 35 (9): 094001. <a href="https://doi.org/10.1088/1361-6420/ab23d1">https://doi.org/10.1088/1361-6420/ab23d1</a>.
</div>
<div id="ref-Barnett_2020" class="csl-entry" role="listitem">
Barnett, Alexander H, Charles L Epstein, Leslie F Greengard, and Jeremy F Magland. 2020. <span>“Geometry of the Phase Retrieval Problem.”</span> <em>Inverse Problems</em> 36 (9): 094003. <a href="https://doi.org/10.1088/1361-6420/aba5ed">https://doi.org/10.1088/1361-6420/aba5ed</a>.
</div>
<div id="ref-Fenimore:78" class="csl-entry" role="listitem">
Fenimore, E. E., and T. M. Cannon. 1978. <span>“Coded Aperture Imaging with Uniformly Redundant Arrays.”</span> <em>Appl. Opt.</em> 17 (3): 337–47. <a href="https://doi.org/10.1364/AO.17.000337">https://doi.org/10.1364/AO.17.000337</a>.
</div>
</div>
</section>
<section id="appendicies" class="level1 unnumbered">
<h1 class="unnumbered">Appendicies</h1>
</section>


<div id="quarto-appendix" class="default"><section id="full-code" class="level1 appendix" data-number="6"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">6</span> Full Stan Code</h2><div class="quarto-appendix-contents">

<div class="sourceCode" id="cb38"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return M1 x M2 matrix of 1 values with blocks in corners set to</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">   * 0, where the upper left is (r x r), the upper right is (r x r-1),</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">   * the lower left is (r-1 x r), and the lower right is (r-1 x r-1).</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">   * This corresponds to zeroing out the lowest-frequency portions of</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">   * an FFT.</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M1 number of rows</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M2 number of cols</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> r block dimension</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> matrix of 1 values with 0-padded corners</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span> beamstop_gen(<span class="dt">int</span> M1, <span class="dt">int</span> M2, <span class="dt">int</span> r) {</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">matrix</span>[M1, M2] B_cal = rep_matrix(<span class="dv">1</span>, M1, M2);</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (r == <span class="dv">0</span>) {</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> B_cal;</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// upper left</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    B_cal[<span class="dv">1</span> : r, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">0</span>, r, r);</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// upper right</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    B_cal[<span class="dv">1</span> : r, M2 - r + <span class="dv">2</span> : M2] = rep_matrix(<span class="dv">0</span>, r, r - <span class="dv">1</span>);</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lower left</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    B_cal[M1 - r + <span class="dv">2</span> : M1, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">0</span>, r - <span class="dv">1</span>, r);</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lower right</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    B_cal[M1 - r + <span class="dv">2</span> : M1, M2 - r + <span class="dv">2</span> : M2] = rep_matrix(<span class="dv">0</span>, r - <span class="dv">1</span>, r - <span class="dv">1</span>);</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_cal;</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return the matrix corresponding to the fast Fourier</span></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a><span class="co">   * transform of Z after it is padded with zeros to size</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a><span class="co">   * N by M</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a><span class="co">   * When N by M is larger than the dimensions of Z,</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a><span class="co">   * this computes an oversampled FFT.</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a><span class="co">   *</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> Z matrix of values</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> N number of rows desired (must be &gt;= rows(Z))</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M number of columns desired (must be &gt;= cols(Z))</span></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> the FFT of Z padded with zeros</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>  <span class="dt">complex_matrix</span> fft2(<span class="dt">complex_matrix</span> Z, <span class="dt">int</span> N, <span class="dt">int</span> M) {</span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> r = rows(Z);</span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c = cols(Z);</span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (r &gt; N) {</span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>      <span class="kw">reject</span>(<span class="st">"N must be at least rows(Z)"</span>);</span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (c &gt; M) {</span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>      <span class="kw">reject</span>(<span class="st">"M must be at least cols(Z)"</span>);</span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">complex_matrix</span>[N, M] pad = rep_matrix(<span class="dv">0</span>, N, M);</span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>    pad[<span class="dv">1</span> : r, <span class="dv">1</span> : c] = Z;</span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fft2(pad);</span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N; <span class="co">// image dimension</span></span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] R; <span class="co">// registration image</span></span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=N&gt; d; <span class="co">// separation between sample and registration image</span></span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=N&gt; M1; <span class="co">// rows of padded matrices</span></span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span> * N + d&gt; M2; <span class="co">// cols of padded matrices</span></span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=M1&gt; r; <span class="co">// beamstop radius. replaces omega1, omega2 in paper</span></span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N_p; <span class="co">// avg number of photons per pixel</span></span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; Y_tilde; <span class="co">// observed number of photons</span></span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-68"><a href="#cb38-68" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma; <span class="co">// standard deviation of pixel prior.</span></span>
<span id="cb38-69"><a href="#cb38-69" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-70"><a href="#cb38-70" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb38-71"><a href="#cb38-71" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] B_cal = beamstop_gen(M1, M2, r);</span>
<span id="cb38-72"><a href="#cb38-72" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[d, N] separation = rep_matrix(<span class="dv">0</span>, d, N);</span>
<span id="cb38-73"><a href="#cb38-73" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-74"><a href="#cb38-74" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb38-75"><a href="#cb38-75" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] X;</span>
<span id="cb38-76"><a href="#cb38-76" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-77"><a href="#cb38-77" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb38-78"><a href="#cb38-78" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ICAR prior / L2 penalty on row/adjacent pixels</span></span>
<span id="cb38-79"><a href="#cb38-79" aria-hidden="true" tabindex="-1"></a>  <span class="co">// to_vector(X[2:N, ]) ~ normal(to_vector(X[1:N - 1, ]), sigma);</span></span>
<span id="cb38-80"><a href="#cb38-80" aria-hidden="true" tabindex="-1"></a>  <span class="co">// to_vector(X[ , 2:N]) ~ normal(to_vector(X[ , 1:N - 1]), sigma);</span></span>
<span id="cb38-81"><a href="#cb38-81" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span> : rows(X) - <span class="dv">1</span>) {</span>
<span id="cb38-82"><a href="#cb38-82" aria-hidden="true" tabindex="-1"></a>    X[i] ~ normal(X[i + <span class="dv">1</span>], sigma);</span>
<span id="cb38-83"><a href="#cb38-83" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb38-84"><a href="#cb38-84" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span> : cols(X) - <span class="dv">1</span>) {</span>
<span id="cb38-85"><a href="#cb38-85" aria-hidden="true" tabindex="-1"></a>    X[ : , j] ~ normal(X[ : , j + <span class="dv">1</span>], sigma);</span>
<span id="cb38-86"><a href="#cb38-86" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb38-87"><a href="#cb38-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-88"><a href="#cb38-88" aria-hidden="true" tabindex="-1"></a>  <span class="co">// likelihood</span></span>
<span id="cb38-89"><a href="#cb38-89" aria-hidden="true" tabindex="-1"></a>  <span class="co">// specimen, separator, and reference concatenated</span></span>
<span id="cb38-90"><a href="#cb38-90" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, <span class="dv">2</span> * N + d] X0R = append_col(X, append_col(separation, R));</span>
<span id="cb38-91"><a href="#cb38-91" aria-hidden="true" tabindex="-1"></a>  <span class="co">// expected signal - squared magnitude of the (oversampled) FFT</span></span>
<span id="cb38-92"><a href="#cb38-92" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] Y = square(abs(fft2(X0R, M1, M2)));</span>
<span id="cb38-93"><a href="#cb38-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-94"><a href="#cb38-94" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> N_p_over_Y_bar = N_p / mean(Y);</span>
<span id="cb38-95"><a href="#cb38-95" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] lambda = N_p_over_Y_bar * Y;</span>
<span id="cb38-96"><a href="#cb38-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-97"><a href="#cb38-97" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (m1 <span class="cf">in</span> <span class="dv">1</span> : M1) {</span>
<span id="cb38-98"><a href="#cb38-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (m2 <span class="cf">in</span> <span class="dv">1</span> : M2) {</span>
<span id="cb38-99"><a href="#cb38-99" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (B_cal[m1, m2] != <span class="dv">0</span>) {</span>
<span id="cb38-100"><a href="#cb38-100" aria-hidden="true" tabindex="-1"></a>        Y_tilde[m1, m2] ~ poisson(lambda[m1, m2]);</span>
<span id="cb38-101"><a href="#cb38-101" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb38-102"><a href="#cb38-102" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb38-103"><a href="#cb38-103" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb38-104"><a href="#cb38-104" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="digression-efficiency" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="digression-efficiency"><span class="header-section-number">6.1</span> Digression: Efficiency</h2>
<p>The model above is coded for readability and sticks closely to the mathematical formulation of the process. However, this does lead to an inefficient condition inside the tightest loop of the model to handle the beamstop occlusion.</p>
<p>In practice, it is possible to avoid this conditional by changing how the data is stored. Instead of storing the beamstop occlusion as a parallel matrix, we can pre-compute the list of indices which are included once and store it. Then, we can create flat representations of both the data <span class="math inline">\tilde{Y}</span> and the rate <span class="math inline">\lambda</span>, allowing us to use a vectorized version of the Poisson distribution.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span> B_cal = beamstop_gen(M1, M2, r);</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> total = sum(to_array_1d(B_cal));</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[total, <span class="dv">2</span>] idxs;</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// pre-compute indices</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> current = <span class="dv">1</span>;</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span>:M1){</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (m <span class="cf">in</span> <span class="dv">1</span>:M2){</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (B_cal[n, m]){</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>        idxs[current, :] = {n,m};</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>        current += <span class="dv">1</span>;</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// flatten data accordingly</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[total] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; Ys;</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span>:total) {</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    Ys[n] = Y_tilde[idxs[n, <span class="dv">1</span>], idxs[n, <span class="dv">2</span>]];</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ... same code for computing matrix[M1, M2] lambda here</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[total] <span class="dt">real</span> lambdas;</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span>:total) {</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    lambdas[n] = lambda[idxs[n, i], idxs[n, j]];  <span class="co">// much cheaper than branching</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>  Ys ~ poisson(lambdas);  <span class="co">// fully vectorized</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This formulation of the model reduces the amount of time per gradient evaluation by 15-20%. A brief evaluation suggests however that the impact on optimization runtime is minimal.</p>
<!-- -->

</section>
</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{ward2024,
  author = {Ward, Brian and Carpenter, Bob and Barmherzig, David},
  publisher = {Société Française de Statistique},
  title = {HoloML in {Stan}},
  journal = {Computo},
  date = {2024-02-29},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    Curabitur posuere vestibulum facilisis. Aenean pretium orci augue,
    quis lobortis libero accumsan eu. Nam mollis lorem sit amet
    pellentesque ullamcorper. Curabitur lobortis libero eget malesuada
    vestibulum. Nam nec nibh massa. Pellentesque porttitor cursus
    tellus. Mauris urna erat, rhoncus sed faucibus sit amet, venenatis
    eu ipsum.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-ward2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Ward, Brian, Bob Carpenter, and David Barmherzig. 2024. <span>“HoloML in
Stan.”</span> <em>Computo</em>, February. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb40" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "HoloML in Stan"</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "Low-photon Image Reconstruction using Bayesian Tools"</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Brian Ward</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: bward@flatironinstitute.org</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://brianward.dev/</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-9841-3342</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Flatiron Institute</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Center for Computational Mathematics</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Bob Carpenter</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="co">    email: bcarpenter@flatironinstitute.org</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://bob-carpenter.github.io/</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-2433-9688</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Flatiron Institute</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Center for Computational Mathematics</span></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/</span></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: David Barmherzig</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a><span class="co">    email: dbarmherzig@flatironinstitute.org</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://davidbar.org/</span></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0003-2466-981X</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Flatiron Institute</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Center for Computational Mathematics</span></span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a><span class="co">  This case study is a reimplementation of the algorithm described in [@Barmherzig:22] as a Stan model. This showcases some new features of Stan, available starting in version 2.30</span></span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a><span class="co">  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur posuere vestibulum facilisis. Aenean pretium orci augue, quis lobortis libero accumsan eu. Nam mollis lorem sit amet pellentesque ullamcorper. Curabitur lobortis libero eget malesuada vestibulum. Nam nec nibh massa. Pellentesque porttitor cursus tellus. Mauris urna erat, rhoncus sed faucibus sit amet, venenatis eu ipsum.</span></span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [stan, coherent-diffraction-imaging, statistics]</span></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> WardBrian</span></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "holoml-in-stan-computo"</span></span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>The HoloML technique is an approach to solving a specific kind of inverse problem inherent to imaging nanoscale specimens using X-ray diffraction.</span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-60"><a href="#cb40-60" aria-hidden="true" tabindex="-1"></a>To solve this problem in Stan, we first write down the forward scientific model given by Barmherzig and Sun, including the Poisson photon distribution and censored data inherent to the physical problem, and then find a solution via penalized maximum likelihood.</span>
<span id="cb40-61"><a href="#cb40-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-62"><a href="#cb40-62" aria-hidden="true" tabindex="-1"></a><span class="fu">## Experimental setup</span></span>
<span id="cb40-63"><a href="#cb40-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-64"><a href="#cb40-64" aria-hidden="true" tabindex="-1"></a>In coherent diffraction imaging (CDI), a radiation source, typically an X-ray, is directed at a biomolecule or other specimen of interest, which causes diffraction. The resulting photon flux is measured by a far-field detector. The expected photon flux is approximately the squared magnitude of the Fourier transform of the electric field causing the diffraction. Inverting this to recover an image of the specimen is a problem usually known as *phase retrieval*. The phase retrieval problem is highly challenging and often lacks a unique solution <span class="co">[</span><span class="ot">@Barnett_2020</span><span class="co">]</span>.</span>
<span id="cb40-65"><a href="#cb40-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-66"><a href="#cb40-66" aria-hidden="true" tabindex="-1"></a>Holographic coherent diffraction imaging (HCDI) is a variant in which the specimen is placed some distance away from a known reference object, and the data observed is the pattern of  diffraction around both the specimen and the reference. The addition of a reference object provides additional constraints on this problem, and transforms it into a linear deconvolution problem which has a unique, closed-form solution in the idealized setting <span class="co">[</span><span class="ot">@Barmherzig_2019</span><span class="co">]</span>.</span>
<span id="cb40-67"><a href="#cb40-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-68"><a href="#cb40-68" aria-hidden="true" tabindex="-1"></a>The idealized version of HCDI is formulated as</span>
<span id="cb40-69"><a href="#cb40-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-70"><a href="#cb40-70" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Given a reference $R$, data $Y = | \mathcal{F}( X + R ) | ^2$</span>
<span id="cb40-71"><a href="#cb40-71" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Recover the source image $X$</span>
<span id="cb40-72"><a href="#cb40-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-73"><a href="#cb40-73" aria-hidden="true" tabindex="-1"></a>Where $\mathcal{F}$ is an oversampled Fourier transform operator.</span>
<span id="cb40-74"><a href="#cb40-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-75"><a href="#cb40-75" aria-hidden="true" tabindex="-1"></a>However, the real-world set up of these experiments introduces two additional difficulties. Data is measured from a limited number of photons, where the number of photons received by each detector is modeled as Poisson distributed with expectation given by $Y_{ij}$ (referred to in the paper as *Poisson-shot noise*). The expected number of photons each detector receives is denoted $N_p$. We typically have $N_p &lt; 10$ due to the damage that radiation causes the biomolecule under observation. Secondly, to prevent damage to the detectors, the lowest frequencies are removed by a *beamstop*, which censors low-frequency observations.</span>
<span id="cb40-76"><a href="#cb40-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-77"><a href="#cb40-77" aria-hidden="true" tabindex="-1"></a>The maximum likelihood estimation of the model presented here is able to recover reasonable images even under a regime featuring low photon counts and a beamstop.</span>
<span id="cb40-78"><a href="#cb40-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-79"><a href="#cb40-79" aria-hidden="true" tabindex="-1"></a><span class="fu"># Simulating Data</span></span>
<span id="cb40-80"><a href="#cb40-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-81"><a href="#cb40-81" aria-hidden="true" tabindex="-1"></a>We simulate data from the generative model directly. This corresponds to the approach taken by Barmherzig and Sun, and is based on MATLAB code provided by Barmherzig.</span>
<span id="cb40-82"><a href="#cb40-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-83"><a href="#cb40-83" aria-hidden="true" tabindex="-1"></a><span class="fu">## Imports and helper code</span></span>
<span id="cb40-84"><a href="#cb40-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-85"><a href="#cb40-85" aria-hidden="true" tabindex="-1"></a>Generating the data requires a few standard Python numerical libraries such as scipy and numpy. Matplotlib is also used to simplify loading in the source image and displaying results.</span>
<span id="cb40-86"><a href="#cb40-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-89"><a href="#cb40-89" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-90"><a href="#cb40-90" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb40-91"><a href="#cb40-91" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb40-92"><a href="#cb40-92" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmdstanpy</span>
<span id="cb40-93"><a href="#cb40-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-94"><a href="#cb40-94" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb40-95"><a href="#cb40-95" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.image <span class="im">as</span> mpimg</span>
<span id="cb40-96"><a href="#cb40-96" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb40-97"><a href="#cb40-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-98"><a href="#cb40-98" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rgb2gray(rgb):</span>
<span id="cb40-99"><a href="#cb40-99" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert a nxmx3 RGB array to a grayscale nxm array.</span></span>
<span id="cb40-100"><a href="#cb40-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-101"><a href="#cb40-101" aria-hidden="true" tabindex="-1"></a><span class="co">    This function uses the same internal coefficients as MATLAB:</span></span>
<span id="cb40-102"><a href="#cb40-102" aria-hidden="true" tabindex="-1"></a><span class="co">    https://www.mathworks.com/help/matlab/ref/rgb2gray.html</span></span>
<span id="cb40-103"><a href="#cb40-103" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb40-104"><a href="#cb40-104" aria-hidden="true" tabindex="-1"></a>    r, g, b <span class="op">=</span> rgb[:, :, <span class="dv">0</span>], rgb[:, :, <span class="dv">1</span>], rgb[:, :, <span class="dv">2</span>]</span>
<span id="cb40-105"><a href="#cb40-105" aria-hidden="true" tabindex="-1"></a>    gray <span class="op">=</span> <span class="fl">0.2989</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.5870</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.1140</span> <span class="op">*</span> b</span>
<span id="cb40-106"><a href="#cb40-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-107"><a href="#cb40-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gray</span>
<span id="cb40-108"><a href="#cb40-108" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-109"><a href="#cb40-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-112"><a href="#cb40-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-113"><a href="#cb40-113" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb40-114"><a href="#cb40-114" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb40-115"><a href="#cb40-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-116"><a href="#cb40-116" aria-hidden="true" tabindex="-1"></a><span class="co"># Extra display settings set, omitted from rendered case study</span></span>
<span id="cb40-117"><a href="#cb40-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-118"><a href="#cb40-118" aria-hidden="true" tabindex="-1"></a><span class="co"># disable axes drawing, since we are showing images</span></span>
<span id="cb40-119"><a href="#cb40-119" aria-hidden="true" tabindex="-1"></a>mpl.rc(<span class="st">'axes.spines'</span>, top<span class="op">=</span><span class="va">False</span>, bottom<span class="op">=</span><span class="va">False</span>, left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb40-120"><a href="#cb40-120" aria-hidden="true" tabindex="-1"></a>mpl.rc(<span class="st">'axes'</span>, facecolor<span class="op">=</span><span class="st">'white'</span>)</span>
<span id="cb40-121"><a href="#cb40-121" aria-hidden="true" tabindex="-1"></a>mpl.rc(<span class="st">"xtick"</span>, bottom<span class="op">=</span><span class="va">False</span>, labelbottom<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb40-122"><a href="#cb40-122" aria-hidden="true" tabindex="-1"></a>mpl.rc(<span class="st">"ytick"</span>, left<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb40-123"><a href="#cb40-123" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-124"><a href="#cb40-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-125"><a href="#cb40-125" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation parameters</span></span>
<span id="cb40-126"><a href="#cb40-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-127"><a href="#cb40-127" aria-hidden="true" tabindex="-1"></a>To match the figures in the paper (in particular, Figure 9), we use an image of size 256x256, $N_p = 1$ (meaning each detector is expected to receive one photon), and a beamstop of size 25x25 (corresponding to a radius of 13), and a separation <span class="in">`d`</span> equal to the size of the image.</span>
<span id="cb40-128"><a href="#cb40-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-131"><a href="#cb40-131" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-132"><a href="#cb40-132" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb40-133"><a href="#cb40-133" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> N</span>
<span id="cb40-134"><a href="#cb40-134" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb40-135"><a href="#cb40-135" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb40-136"><a href="#cb40-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-137"><a href="#cb40-137" aria-hidden="true" tabindex="-1"></a>M1 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> N</span>
<span id="cb40-138"><a href="#cb40-138" aria-hidden="true" tabindex="-1"></a>M2 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> d)</span>
<span id="cb40-139"><a href="#cb40-139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-140"><a href="#cb40-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-141"><a href="#cb40-141" aria-hidden="true" tabindex="-1"></a>We can then load the source image used for these simulations. In this model, the pixels of $X$ grayscale values represented on the interval <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>. A conversion is done here from the standard RGBA encoding using the above <span class="in">`rgb2gray`</span> function.</span>
<span id="cb40-142"><a href="#cb40-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-143"><a href="#cb40-143" aria-hidden="true" tabindex="-1"></a>The following is a picture of a <span class="co">[</span><span class="ot">giant virus</span><span class="co">](https://en.wikipedia.org/wiki/Giant_virus)</span> known as a mimivirus.</span>
<span id="cb40-144"><a href="#cb40-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-145"><a href="#cb40-145" aria-hidden="true" tabindex="-1"></a>Image credit: &lt;a href="https://commons.wikimedia.org/wiki/File:Electron_microscopic_image_of_a_mimivirus_-_journal.ppat.1000087.g007_crop.png"&gt;Ghigo E, Kartenbeck J, Lien P, Pelkmans L, Capo C, Mege JL, Raoult D.&lt;/a&gt;, &lt;a href="https://creativecommons.org/licenses/by/2.5"&gt;CC BY 2.5&lt;/a&gt;, via Wikimedia Commons</span>
<span id="cb40-146"><a href="#cb40-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-149"><a href="#cb40-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-150"><a href="#cb40-150" aria-hidden="true" tabindex="-1"></a>X_src <span class="op">=</span> rgb2gray(mpimg.imread(<span class="st">'mimivirus.png'</span>))</span>
<span id="cb40-151"><a href="#cb40-151" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_src, cmap<span class="op">=</span><span class="st">'gray'</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-152"><a href="#cb40-152" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-153"><a href="#cb40-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-154"><a href="#cb40-154" aria-hidden="true" tabindex="-1"></a>Additionally, we load in the pattern of the reference object.</span>
<span id="cb40-155"><a href="#cb40-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-156"><a href="#cb40-156" aria-hidden="true" tabindex="-1"></a>The pattern used here is known as a *uniformly redundant array* (URA) <span class="co">[</span><span class="ot">@Fenimore:78</span><span class="co">]</span>. It has been shown to be an optimal reference image for this kind of work, but other references (including none at all) could be used with the same Stan model.</span>
<span id="cb40-157"><a href="#cb40-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-158"><a href="#cb40-158" aria-hidden="true" tabindex="-1"></a>The code used to generate this grid is omitted from this case study. Various options such as <span class="co">[</span><span class="ot">cappy</span><span class="co">](https://github.com/bpops/cappy)</span> exist to generate these patterns in Python.</span>
<span id="cb40-159"><a href="#cb40-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-162"><a href="#cb40-162" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-163"><a href="#cb40-163" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.loadtxt(<span class="st">'URA.csv'</span>, delimiter<span class="op">=</span><span class="st">","</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb40-164"><a href="#cb40-164" aria-hidden="true" tabindex="-1"></a>plt.imshow(R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb40-165"><a href="#cb40-165" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-166"><a href="#cb40-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-167"><a href="#cb40-167" aria-hidden="true" tabindex="-1"></a>We create the specimen-reference hybrid image by concatenating the $X$ image, a matrix of zeros, and the reference $R$. In the true experiment, this is done by placing the specimen some distance <span class="in">`d`</span> away from the reference, with opaque material between.</span>
<span id="cb40-168"><a href="#cb40-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-169"><a href="#cb40-169" aria-hidden="true" tabindex="-1"></a>This distance is typically the same as the size of the specimen, <span class="in">`N`</span>. One contribution of the HoloML model is allowing recovery with the reference placed closer to the specimen, and the Stan model allows for this as well.</span>
<span id="cb40-170"><a href="#cb40-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-171"><a href="#cb40-171" aria-hidden="true" tabindex="-1"></a>For this simulation we use the separation of <span class="in">`d = N`</span>.</span>
<span id="cb40-172"><a href="#cb40-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-175"><a href="#cb40-175" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-176"><a href="#cb40-176" aria-hidden="true" tabindex="-1"></a><span class="co">#| tags: [hide-code]</span></span>
<span id="cb40-177"><a href="#cb40-177" aria-hidden="true" tabindex="-1"></a>mpl.rc(<span class="st">"figure"</span>, autolayout<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="fl">10.5</span>, <span class="fl">7.5</span>))</span>
<span id="cb40-178"><a href="#cb40-178" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-179"><a href="#cb40-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-182"><a href="#cb40-182" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-183"><a href="#cb40-183" aria-hidden="true" tabindex="-1"></a>X0R <span class="op">=</span> np.concatenate([X_src, np.zeros((N,d)), R], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-184"><a href="#cb40-184" aria-hidden="true" tabindex="-1"></a>plt.imshow(X0R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb40-185"><a href="#cb40-185" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-186"><a href="#cb40-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-187"><a href="#cb40-187" aria-hidden="true" tabindex="-1"></a>We can simulate the diffraction pattern of photons from the X-ray by taking the absolute value squared of the 2-dimensional oversampled FFT of this hybrid object.</span>
<span id="cb40-188"><a href="#cb40-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-189"><a href="#cb40-189" aria-hidden="true" tabindex="-1"></a>The oversampled FFT (denoted $\mathcal{F}$ in the paper) corresponds to padding the image in both dimensions with zeros until it is a desired size. For our case, we define the size of the padded image, <span class="in">`M1`</span> by <span class="in">`M2`</span>, to be two times the size of our hybrid image, so the resulting FFT is twice oversampled. This is the oversampling ratio traditionally used for this problem, however Barmherzig and Sun also showed that this model can operate with less oversampling as well.</span>
<span id="cb40-190"><a href="#cb40-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-193"><a href="#cb40-193" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-194"><a href="#cb40-194" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.fft2(X0R, s<span class="op">=</span>(M1, M2))) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb40-195"><a href="#cb40-195" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(np.log1p(Y)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb40-196"><a href="#cb40-196" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-197"><a href="#cb40-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-198"><a href="#cb40-198" aria-hidden="true" tabindex="-1"></a>We simulate the photon fluxes with a Poisson pseudorandom number generator.</span>
<span id="cb40-199"><a href="#cb40-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-200"><a href="#cb40-200" aria-hidden="true" tabindex="-1"></a>This code specifies a fixed seed to ensure the same fake data is generated each time.</span>
<span id="cb40-201"><a href="#cb40-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-204"><a href="#cb40-204" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-205"><a href="#cb40-205" aria-hidden="true" tabindex="-1"></a>rate <span class="op">=</span> N_p <span class="op">/</span> Y.mean()</span>
<span id="cb40-206"><a href="#cb40-206" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">=</span> stats.poisson.rvs(rate <span class="op">*</span> Y, random_state<span class="op">=</span><span class="dv">1234</span>)</span>
<span id="cb40-207"><a href="#cb40-207" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(np.log1p(Y_tilde)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb40-208"><a href="#cb40-208" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-209"><a href="#cb40-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-210"><a href="#cb40-210" aria-hidden="true" tabindex="-1"></a>Finally, we need to remove the low frequency content of the data. This is caused in the physical experiment by the inclusion of a beamstop, which protects the instrument used by preventing the strongest parts of the beam from directly shining on the detectors.</span>
<span id="cb40-211"><a href="#cb40-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-212"><a href="#cb40-212" aria-hidden="true" tabindex="-1"></a>The beamstop is represented by $\mathcal{B}$, a matrix of 0s and 1s. Zeros indicate that the data is occluded, while ones represent transparent portions.</span>
<span id="cb40-213"><a href="#cb40-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-216"><a href="#cb40-216" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-217"><a href="#cb40-217" aria-hidden="true" tabindex="-1"></a>B_cal <span class="op">=</span> np.ones((M1,M2), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb40-218"><a href="#cb40-218" aria-hidden="true" tabindex="-1"></a>B_cal[M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r, M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb40-219"><a href="#cb40-219" aria-hidden="true" tabindex="-1"></a>B_cal <span class="op">=</span> np.fft.ifftshift(B_cal)</span>
<span id="cb40-220"><a href="#cb40-220" aria-hidden="true" tabindex="-1"></a><span class="co"># Sanity check</span></span>
<span id="cb40-221"><a href="#cb40-221" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (M1 <span class="op">*</span> M2 <span class="op">-</span> B_cal.<span class="bu">sum</span>()) <span class="op">==</span> (( <span class="dv">2</span> <span class="op">*</span> r <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb40-222"><a href="#cb40-222" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(B_cal), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="fl">1.25</span>)</span>
<span id="cb40-223"><a href="#cb40-223" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-224"><a href="#cb40-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-225"><a href="#cb40-225" aria-hidden="true" tabindex="-1"></a>We use this matrix $\mathcal{B}$ to mask the low frequencies of the simulated data. After removing these elements from the simulated data, we have the final input which is used in our model</span>
<span id="cb40-226"><a href="#cb40-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-229"><a href="#cb40-229" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-230"><a href="#cb40-230" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">*=</span> B_cal</span>
<span id="cb40-231"><a href="#cb40-231" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.fft.fftshift(np.log1p(Y_tilde)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb40-232"><a href="#cb40-232" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-233"><a href="#cb40-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-234"><a href="#cb40-234" aria-hidden="true" tabindex="-1"></a><span class="fu"># Stan Model</span></span>
<span id="cb40-235"><a href="#cb40-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-236"><a href="#cb40-236" aria-hidden="true" tabindex="-1"></a>The Stan model code is a direct translation of the log density of the forward model described in the paper <span class="co">[</span><span class="ot">@Barmherzig:22</span><span class="co">]</span> and above. The full model can be seen in the <span class="co">[</span><span class="ot">appendix</span><span class="co">](#full-code)</span>.</span>
<span id="cb40-237"><a href="#cb40-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-238"><a href="#cb40-238" aria-hidden="true" tabindex="-1"></a><span class="fu">## Functions</span></span>
<span id="cb40-239"><a href="#cb40-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-240"><a href="#cb40-240" aria-hidden="true" tabindex="-1"></a>We define two helper functions to implement this model in Stan. The first is a function responsible for generating the $\mathcal{B}$ matrix. Because Stan currently does not have FFT shifting functions, this is done by manually assigning to the corners of the matrix</span>
<span id="cb40-241"><a href="#cb40-241" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-242"><a href="#cb40-242" aria-hidden="true" tabindex="-1"></a><span class="in">functions {</span></span>
<span id="cb40-243"><a href="#cb40-243" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix beamstop_gen(int M1, int M2, int r) {</span></span>
<span id="cb40-244"><a href="#cb40-244" aria-hidden="true" tabindex="-1"></a><span class="in">    matrix[M1, M2] B_cal = rep_matrix(1, M1, M2);</span></span>
<span id="cb40-245"><a href="#cb40-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-246"><a href="#cb40-246" aria-hidden="true" tabindex="-1"></a><span class="in">    // upper left</span></span>
<span id="cb40-247"><a href="#cb40-247" aria-hidden="true" tabindex="-1"></a><span class="in">    B_cal[1 : r, 1 : r] = rep_matrix(0, r, r);</span></span>
<span id="cb40-248"><a href="#cb40-248" aria-hidden="true" tabindex="-1"></a><span class="in">    // upper right</span></span>
<span id="cb40-249"><a href="#cb40-249" aria-hidden="true" tabindex="-1"></a><span class="in">    B_cal[1 : r, M2 - r + 2 : M2] = rep_matrix(0, r, r - 1);</span></span>
<span id="cb40-250"><a href="#cb40-250" aria-hidden="true" tabindex="-1"></a><span class="in">    // lower left</span></span>
<span id="cb40-251"><a href="#cb40-251" aria-hidden="true" tabindex="-1"></a><span class="in">    B_cal[M1 - r + 2 : M1, 1 : r] = rep_matrix(0, r - 1, r);</span></span>
<span id="cb40-252"><a href="#cb40-252" aria-hidden="true" tabindex="-1"></a><span class="in">    // lower right</span></span>
<span id="cb40-253"><a href="#cb40-253" aria-hidden="true" tabindex="-1"></a><span class="in">    B_cal[M1 - r + 2 : M1, M2 - r + 2 : M2] = rep_matrix(0, r - 1, r - 1);</span></span>
<span id="cb40-254"><a href="#cb40-254" aria-hidden="true" tabindex="-1"></a><span class="in">    return B_cal;</span></span>
<span id="cb40-255"><a href="#cb40-255" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-256"><a href="#cb40-256" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-257"><a href="#cb40-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-258"><a href="#cb40-258" aria-hidden="true" tabindex="-1"></a>The FFT described in the paper is an oversampled FFT. This corresponds to embedding the image in a larger array of zeros and results in a sort of interpolation between frequencies in the result.</span>
<span id="cb40-259"><a href="#cb40-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-260"><a href="#cb40-260" aria-hidden="true" tabindex="-1"></a>We write an overload of the <span class="in">`fft2`</span> function which implements this behavior, similar to the signatures found in Matlab or Python libraries.</span>
<span id="cb40-261"><a href="#cb40-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-262"><a href="#cb40-262" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-263"><a href="#cb40-263" aria-hidden="true" tabindex="-1"></a><span class="in">  complex_matrix fft2(complex_matrix Z, int N, int M) {</span></span>
<span id="cb40-264"><a href="#cb40-264" aria-hidden="true" tabindex="-1"></a><span class="in">    int r = rows(Z);</span></span>
<span id="cb40-265"><a href="#cb40-265" aria-hidden="true" tabindex="-1"></a><span class="in">    int c = cols(Z);</span></span>
<span id="cb40-266"><a href="#cb40-266" aria-hidden="true" tabindex="-1"></a><span class="in">    complex_matrix[N, M] pad = rep_matrix(0, N, M);</span></span>
<span id="cb40-267"><a href="#cb40-267" aria-hidden="true" tabindex="-1"></a><span class="in">    pad[1 : r, 1 : c] = Z;</span></span>
<span id="cb40-268"><a href="#cb40-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-269"><a href="#cb40-269" aria-hidden="true" tabindex="-1"></a><span class="in">    return fft2(pad);</span></span>
<span id="cb40-270"><a href="#cb40-270" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-271"><a href="#cb40-271" aria-hidden="true" tabindex="-1"></a><span class="in">} // end functions block</span></span>
<span id="cb40-272"><a href="#cb40-272" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-273"><a href="#cb40-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-274"><a href="#cb40-274" aria-hidden="true" tabindex="-1"></a>Note that while the first input of this function is a <span class="in">`complex_matrix`</span>, it will also accept real matrices due to the built-in type promotion in Stan.</span>
<span id="cb40-275"><a href="#cb40-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-276"><a href="#cb40-276" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model inputs</span></span>
<span id="cb40-277"><a href="#cb40-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-278"><a href="#cb40-278" aria-hidden="true" tabindex="-1"></a>The Stan model needs the same information the generative model did, except it is supplied with $\tilde{Y}$ instead of the source image $X$, plus a scale parameter for the prior, $\sigma$. Smaller values of $\sigma$ (approaching 0) lead to increasing amounts of blur in the resulting image.</span>
<span id="cb40-279"><a href="#cb40-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-280"><a href="#cb40-280" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-281"><a href="#cb40-281" aria-hidden="true" tabindex="-1"></a><span class="in">data {</span></span>
<span id="cb40-282"><a href="#cb40-282" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=0&gt; N;                    // image dimension</span></span>
<span id="cb40-283"><a href="#cb40-283" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix&lt;lower=0, upper=1&gt;[N, N] R;  // reference image</span></span>
<span id="cb40-284"><a href="#cb40-284" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=0, upper=N&gt; d;           // separation between sample and reference image</span></span>
<span id="cb40-285"><a href="#cb40-285" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=N&gt; M1;                   // rows of padded matrices</span></span>
<span id="cb40-286"><a href="#cb40-286" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=2 * N + d&gt; M2;           // cols of padded matrices</span></span>
<span id="cb40-287"><a href="#cb40-287" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=0, upper=M1&gt; r;          // beamstop radius. replaces omega1, omega2 in paper</span></span>
<span id="cb40-288"><a href="#cb40-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-289"><a href="#cb40-289" aria-hidden="true" tabindex="-1"></a><span class="in">  real&lt;lower=0&gt; N_p;                  // avg number of photons per pixel</span></span>
<span id="cb40-290"><a href="#cb40-290" aria-hidden="true" tabindex="-1"></a><span class="in">  array[M1, M2] int&lt;lower=0&gt; Y_tilde; // observed number of photons</span></span>
<span id="cb40-291"><a href="#cb40-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-292"><a href="#cb40-292" aria-hidden="true" tabindex="-1"></a><span class="in">  real&lt;lower=0&gt; sigma;                // standard deviation of pixel prior.</span></span>
<span id="cb40-293"><a href="#cb40-293" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb40-294"><a href="#cb40-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-295"><a href="#cb40-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-296"><a href="#cb40-296" aria-hidden="true" tabindex="-1"></a>The constraints listed above, such as <span class="in">`lower=0`</span>, perform input validation. For example, the size of the padded FFT is, at a minimum, the size of the hybrid $X0R$ specimen, and we are able to encode this in the model with the lower bounds on <span class="in">`M1`</span> and <span class="in">`M2`</span>.</span>
<span id="cb40-297"><a href="#cb40-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-298"><a href="#cb40-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-299"><a href="#cb40-299" aria-hidden="true" tabindex="-1"></a><span class="fu">## Additional fixed information</span></span>
<span id="cb40-300"><a href="#cb40-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-301"><a href="#cb40-301" aria-hidden="true" tabindex="-1"></a>Stan provides the ability to compute transformed data, values which depend on the inputs but only need to be evaluated once per model. This allows us to construct and store $\mathcal{B}$ once, without recomputing it each iteration or requiring it as input.</span>
<span id="cb40-302"><a href="#cb40-302" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-303"><a href="#cb40-303" aria-hidden="true" tabindex="-1"></a><span class="in">transformed data {</span></span>
<span id="cb40-304"><a href="#cb40-304" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[M1, M2] B_cal = beamstop_gen(M1, M2, r);</span></span>
<span id="cb40-305"><a href="#cb40-305" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[d, N] separation = rep_matrix(0, d, N);</span></span>
<span id="cb40-306"><a href="#cb40-306" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb40-307"><a href="#cb40-307" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-308"><a href="#cb40-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-309"><a href="#cb40-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-310"><a href="#cb40-310" aria-hidden="true" tabindex="-1"></a><span class="fu">## Parameters</span></span>
<span id="cb40-311"><a href="#cb40-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-312"><a href="#cb40-312" aria-hidden="true" tabindex="-1"></a>This model has only one parameter, the image $X$. It is constrained to grayscale values between 0 and 1.</span>
<span id="cb40-313"><a href="#cb40-313" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-314"><a href="#cb40-314" aria-hidden="true" tabindex="-1"></a><span class="in">parameters {</span></span>
<span id="cb40-315"><a href="#cb40-315" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix&lt;lower=0, upper=1&gt;[N, N] X;</span></span>
<span id="cb40-316"><a href="#cb40-316" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb40-317"><a href="#cb40-317" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-318"><a href="#cb40-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-319"><a href="#cb40-319" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model code</span></span>
<span id="cb40-320"><a href="#cb40-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-321"><a href="#cb40-321" aria-hidden="true" tabindex="-1"></a><span class="fu">### Priors</span></span>
<span id="cb40-322"><a href="#cb40-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-323"><a href="#cb40-323" aria-hidden="true" tabindex="-1"></a>We add a prior on $X$ to impose an L2 penalty on adjacent pixels. This induces a Gaussian blur on the result, and it is not strictly necessary for running the model.</span>
<span id="cb40-324"><a href="#cb40-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-325"><a href="#cb40-325" aria-hidden="true" tabindex="-1"></a>This prior is coded in our Stan program by looping over the rows and columns and using a vectorized call to the <span class="in">`normal`</span> distribution. This results in each pixel being adjacent to 4 others. One could also formulate a prior which includes diagonally adjacent pixels</span>
<span id="cb40-326"><a href="#cb40-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-327"><a href="#cb40-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-328"><a href="#cb40-328" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-329"><a href="#cb40-329" aria-hidden="true" tabindex="-1"></a><span class="in">model {</span></span>
<span id="cb40-330"><a href="#cb40-330" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in 1 : rows(X) - 1) {</span></span>
<span id="cb40-331"><a href="#cb40-331" aria-hidden="true" tabindex="-1"></a><span class="in">    X[i] ~ normal(X[i + 1], sigma);</span></span>
<span id="cb40-332"><a href="#cb40-332" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-333"><a href="#cb40-333" aria-hidden="true" tabindex="-1"></a><span class="in">  for (j in 1 : cols(X) - 1) {</span></span>
<span id="cb40-334"><a href="#cb40-334" aria-hidden="true" tabindex="-1"></a><span class="in">    X[ : , j] ~ normal(X[ : , j + 1], sigma);</span></span>
<span id="cb40-335"><a href="#cb40-335" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-336"><a href="#cb40-336" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-337"><a href="#cb40-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-338"><a href="#cb40-338" aria-hidden="true" tabindex="-1"></a><span class="fu">### Likelihood</span></span>
<span id="cb40-339"><a href="#cb40-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-340"><a href="#cb40-340" aria-hidden="true" tabindex="-1"></a>The model likelihood encodes the forward model. We construct the hybrid specimen, compute $|\mathcal{F}(X0R)|^2$, and then compute the rate $\lambda$ by scaling by the average number of photons $N_p$.</span>
<span id="cb40-341"><a href="#cb40-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-342"><a href="#cb40-342" aria-hidden="true" tabindex="-1"></a>We then loop over this result. If the current indices are not occluded by the beamstop $\mathcal{B}$, we say that the data $\tilde{Y}$ is distributed by a Poisson distribution with $\lambda$ as the rate parameter.</span>
<span id="cb40-343"><a href="#cb40-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-344"><a href="#cb40-344" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-345"><a href="#cb40-345" aria-hidden="true" tabindex="-1"></a><span class="in">  // object representing specimen and reference together</span></span>
<span id="cb40-346"><a href="#cb40-346" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[N, 2 * N + d] X0R = append_col(X, append_col(separation, R));</span></span>
<span id="cb40-347"><a href="#cb40-347" aria-hidden="true" tabindex="-1"></a><span class="in">  // signal - squared magnitude of the (oversampled) FFT</span></span>
<span id="cb40-348"><a href="#cb40-348" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[M1, M2] Y = abs(fft2(X0R, M1, M2)) .^ 2;</span></span>
<span id="cb40-349"><a href="#cb40-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-350"><a href="#cb40-350" aria-hidden="true" tabindex="-1"></a><span class="in">  real N_p_over_Y_bar = N_p / mean(Y);</span></span>
<span id="cb40-351"><a href="#cb40-351" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[M1, M2] lambda = N_p_over_Y_bar * Y;</span></span>
<span id="cb40-352"><a href="#cb40-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-353"><a href="#cb40-353" aria-hidden="true" tabindex="-1"></a><span class="in">  for (m1 in 1 : M1) {</span></span>
<span id="cb40-354"><a href="#cb40-354" aria-hidden="true" tabindex="-1"></a><span class="in">    for (m2 in 1 : M2) {</span></span>
<span id="cb40-355"><a href="#cb40-355" aria-hidden="true" tabindex="-1"></a><span class="in">      if (B_cal[m1, m2] != 0) {</span></span>
<span id="cb40-356"><a href="#cb40-356" aria-hidden="true" tabindex="-1"></a><span class="in">        Y_tilde[m1, m2] ~ poisson(lambda[m1, m2]);</span></span>
<span id="cb40-357"><a href="#cb40-357" aria-hidden="true" tabindex="-1"></a><span class="in">      }</span></span>
<span id="cb40-358"><a href="#cb40-358" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb40-359"><a href="#cb40-359" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-360"><a href="#cb40-360" aria-hidden="true" tabindex="-1"></a><span class="in">} // end model block</span></span>
<span id="cb40-361"><a href="#cb40-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-362"><a href="#cb40-362" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-363"><a href="#cb40-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-364"><a href="#cb40-364" aria-hidden="true" tabindex="-1"></a><span class="fu"># Optimization</span></span>
<span id="cb40-365"><a href="#cb40-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-366"><a href="#cb40-366" aria-hidden="true" tabindex="-1"></a>Now that we have our simulated data and our generative model, we solve the inverse problem.</span>
<span id="cb40-367"><a href="#cb40-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-368"><a href="#cb40-368" aria-hidden="true" tabindex="-1"></a><span class="fu">## Data preparation</span></span>
<span id="cb40-369"><a href="#cb40-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-370"><a href="#cb40-370" aria-hidden="true" tabindex="-1"></a>We prepare a dictionary of data corresponding to the models <span class="in">`data`</span> block. This is mostly reusing constants defined earlier for the data simulation.</span>
<span id="cb40-371"><a href="#cb40-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-374"><a href="#cb40-374" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-375"><a href="#cb40-375" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span> <span class="co"># prior smoothing</span></span>
<span id="cb40-376"><a href="#cb40-376" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb40-377"><a href="#cb40-377" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N"</span>: N,</span>
<span id="cb40-378"><a href="#cb40-378" aria-hidden="true" tabindex="-1"></a>    <span class="st">"R"</span>: R,</span>
<span id="cb40-379"><a href="#cb40-379" aria-hidden="true" tabindex="-1"></a>    <span class="st">"d"</span>: N,</span>
<span id="cb40-380"><a href="#cb40-380" aria-hidden="true" tabindex="-1"></a>    <span class="st">"M1"</span>: M1,</span>
<span id="cb40-381"><a href="#cb40-381" aria-hidden="true" tabindex="-1"></a>    <span class="st">"M2"</span>: M2,</span>
<span id="cb40-382"><a href="#cb40-382" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Y_tilde"</span>: Y_tilde,</span>
<span id="cb40-383"><a href="#cb40-383" aria-hidden="true" tabindex="-1"></a>    <span class="st">"r"</span>: r,</span>
<span id="cb40-384"><a href="#cb40-384" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N_p"</span>: N_p,</span>
<span id="cb40-385"><a href="#cb40-385" aria-hidden="true" tabindex="-1"></a>    <span class="st">"sigma"</span>: sigma</span>
<span id="cb40-386"><a href="#cb40-386" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb40-387"><a href="#cb40-387" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-388"><a href="#cb40-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-389"><a href="#cb40-389" aria-hidden="true" tabindex="-1"></a>To run the model from Python, we instantiate it as a CmdStanModel object from cmdstanpy.</span>
<span id="cb40-390"><a href="#cb40-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-393"><a href="#cb40-393" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-394"><a href="#cb40-394" aria-hidden="true" tabindex="-1"></a>HoloML_model <span class="op">=</span> cmdstanpy.CmdStanModel(stan_file<span class="op">=</span><span class="st">"./holoml.stan"</span>)</span>
<span id="cb40-395"><a href="#cb40-395" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-396"><a href="#cb40-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-397"><a href="#cb40-397" aria-hidden="true" tabindex="-1"></a>Here we use optimization via the limited-memory quasi-Newton L-BFGS algorithm. This method has a bit more curvature information than what is available to the conjugate gradient approach, but less than the second order trust-region method used in the paper. This should take a few (1-3) minutes, depending on the machine you are running on.</span>
<span id="cb40-398"><a href="#cb40-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-399"><a href="#cb40-399" aria-hidden="true" tabindex="-1"></a>It is also possible to sample the model using the No-U-Turn Sampler (NUTS), but evaluations of this are out of the scope of this case study.</span>
<span id="cb40-400"><a href="#cb40-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-403"><a href="#cb40-403" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-404"><a href="#cb40-404" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit <span class="op">=</span> HoloML_model.optimize(data, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span>
<span id="cb40-405"><a href="#cb40-405" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-406"><a href="#cb40-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-407"><a href="#cb40-407" aria-hidden="true" tabindex="-1"></a>We use the function <span class="in">`stan_variable`</span> to extract the maximum likelihood estimate (MLE) from the fit object returned by optimization.</span>
<span id="cb40-408"><a href="#cb40-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-409"><a href="#cb40-409" aria-hidden="true" tabindex="-1"></a>We can use this to plot the recovered image alongside the original.</span>
<span id="cb40-410"><a href="#cb40-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-413"><a href="#cb40-413" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-414"><a href="#cb40-414" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb40-415"><a href="#cb40-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-416"><a href="#cb40-416" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, title<span class="op">=</span><span class="st">"Source Image"</span>)</span>
<span id="cb40-417"><a href="#cb40-417" aria-hidden="true" tabindex="-1"></a>ax1.imshow(X_src, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-418"><a href="#cb40-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-419"><a href="#cb40-419" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, title<span class="op">=</span><span class="st">"Recovered Image"</span>)</span>
<span id="cb40-420"><a href="#cb40-420" aria-hidden="true" tabindex="-1"></a>ax2.imshow(fit.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-421"><a href="#cb40-421" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-422"><a href="#cb40-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-423"><a href="#cb40-423" aria-hidden="true" tabindex="-1"></a><span class="fu"># Varying $N_p$</span></span>
<span id="cb40-424"><a href="#cb40-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-425"><a href="#cb40-425" aria-hidden="true" tabindex="-1"></a>The above selection of $N_p=1$ is a reasonable choice for real experiment, but both smaller and larger numbers of expected photons may be used. The following are results for two other levels, $N_p = 0.1$ and $N_p = 10$</span>
<span id="cb40-426"><a href="#cb40-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-427"><a href="#cb40-427" aria-hidden="true" tabindex="-1"></a>This requires repeating the final few steps of the data generation and then re-fitting the model accordingly.</span>
<span id="cb40-428"><a href="#cb40-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-431"><a href="#cb40-431" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-432"><a href="#cb40-432" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb40-433"><a href="#cb40-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-434"><a href="#cb40-434" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">=</span> stats.poisson.rvs((N_p <span class="op">/</span> Y.mean()) <span class="op">*</span> Y, random_state<span class="op">=</span><span class="dv">1234</span>) <span class="op">*</span> B_cal</span>
<span id="cb40-435"><a href="#cb40-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-436"><a href="#cb40-436" aria-hidden="true" tabindex="-1"></a>data_fewer_photons <span class="op">=</span> data.copy()</span>
<span id="cb40-437"><a href="#cb40-437" aria-hidden="true" tabindex="-1"></a>data_fewer_photons[<span class="st">'N_p'</span>] <span class="op">=</span> N_p</span>
<span id="cb40-438"><a href="#cb40-438" aria-hidden="true" tabindex="-1"></a>data_fewer_photons[<span class="st">'Y_tilde'</span>] <span class="op">=</span> Y_tilde</span>
<span id="cb40-439"><a href="#cb40-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-440"><a href="#cb40-440" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_fewer_photons <span class="op">=</span> HoloML_model.optimize(data_fewer_photons, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span>
<span id="cb40-441"><a href="#cb40-441" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-442"><a href="#cb40-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-445"><a href="#cb40-445" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-446"><a href="#cb40-446" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb40-447"><a href="#cb40-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-448"><a href="#cb40-448" aria-hidden="true" tabindex="-1"></a>Y_tilde <span class="op">=</span> stats.poisson.rvs((N_p <span class="op">/</span> Y.mean()) <span class="op">*</span> Y, random_state<span class="op">=</span><span class="dv">1234</span>) <span class="op">*</span> B_cal</span>
<span id="cb40-449"><a href="#cb40-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-450"><a href="#cb40-450" aria-hidden="true" tabindex="-1"></a>data_more_photons <span class="op">=</span> data.copy()</span>
<span id="cb40-451"><a href="#cb40-451" aria-hidden="true" tabindex="-1"></a>data_more_photons[<span class="st">'N_p'</span>] <span class="op">=</span> N_p</span>
<span id="cb40-452"><a href="#cb40-452" aria-hidden="true" tabindex="-1"></a>data_more_photons[<span class="st">'Y_tilde'</span>] <span class="op">=</span> Y_tilde</span>
<span id="cb40-453"><a href="#cb40-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-454"><a href="#cb40-454" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_more_photons <span class="op">=</span> HoloML_model.optimize(data_more_photons, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span>
<span id="cb40-455"><a href="#cb40-455" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-456"><a href="#cb40-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-457"><a href="#cb40-457" aria-hidden="true" tabindex="-1"></a>It is worth noting that these two optimizations take very different amounts of time compared to the original, as the differing amounts of data yield posteriors which are more or less normal.</span>
<span id="cb40-458"><a href="#cb40-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-459"><a href="#cb40-459" aria-hidden="true" tabindex="-1"></a>In addition to the difference in runtime, the resulting images are very different.</span>
<span id="cb40-460"><a href="#cb40-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-463"><a href="#cb40-463" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-464"><a href="#cb40-464" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb40-465"><a href="#cb40-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-466"><a href="#cb40-466" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, title<span class="op">=</span><span class="st">"Source Image"</span>)</span>
<span id="cb40-467"><a href="#cb40-467" aria-hidden="true" tabindex="-1"></a>ax1.imshow(X_src, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-468"><a href="#cb40-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-469"><a href="#cb40-469" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($N_p=10$)"</span>)</span>
<span id="cb40-470"><a href="#cb40-470" aria-hidden="true" tabindex="-1"></a>ax2.imshow(fit_more_photons.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-471"><a href="#cb40-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-472"><a href="#cb40-472" aria-hidden="true" tabindex="-1"></a>ax3 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($N_p=1$)"</span>)</span>
<span id="cb40-473"><a href="#cb40-473" aria-hidden="true" tabindex="-1"></a>ax3.imshow(fit.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-474"><a href="#cb40-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-475"><a href="#cb40-475" aria-hidden="true" tabindex="-1"></a>ax4 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($N_p=0.1$)"</span>)</span>
<span id="cb40-476"><a href="#cb40-476" aria-hidden="true" tabindex="-1"></a>ax4.imshow(fit_fewer_photons.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-477"><a href="#cb40-477" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-478"><a href="#cb40-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-479"><a href="#cb40-479" aria-hidden="true" tabindex="-1"></a><span class="fu">## Prior tuning</span></span>
<span id="cb40-480"><a href="#cb40-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-481"><a href="#cb40-481" aria-hidden="true" tabindex="-1"></a>The above choice of $\sigma = 1$ has a very slight effect on the output image.</span>
<span id="cb40-482"><a href="#cb40-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-483"><a href="#cb40-483" aria-hidden="true" tabindex="-1"></a>We also show the recovered image for $\sigma = 20$, which provides even less smoothing than the above, and for $\sigma = 0.05$. This smaller value imposes a greater penalty on adjacent pixels which are significantly different than each other, smoothing out the result.</span>
<span id="cb40-484"><a href="#cb40-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-485"><a href="#cb40-485" aria-hidden="true" tabindex="-1"></a>Each of these is done with the original value of $N_p = 1$</span>
<span id="cb40-486"><a href="#cb40-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-489"><a href="#cb40-489" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-490"><a href="#cb40-490" aria-hidden="true" tabindex="-1"></a>data_weaker_prior <span class="op">=</span> data.copy()</span>
<span id="cb40-491"><a href="#cb40-491" aria-hidden="true" tabindex="-1"></a>data_weaker_prior[<span class="st">'sigma'</span>] <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb40-492"><a href="#cb40-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-493"><a href="#cb40-493" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_rougher <span class="op">=</span> HoloML_model.optimize(data_weaker_prior, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span>
<span id="cb40-494"><a href="#cb40-494" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-495"><a href="#cb40-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-498"><a href="#cb40-498" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-499"><a href="#cb40-499" aria-hidden="true" tabindex="-1"></a>data_stronger_prior <span class="op">=</span> data.copy()</span>
<span id="cb40-500"><a href="#cb40-500" aria-hidden="true" tabindex="-1"></a>data_stronger_prior[<span class="st">'sigma'</span>] <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb40-501"><a href="#cb40-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-502"><a href="#cb40-502" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time fit_smooth <span class="op">=</span> HoloML_model.optimize(data_stronger_prior, inits<span class="op">=</span><span class="dv">1</span>, seed<span class="op">=</span><span class="dv">5678</span>)</span>
<span id="cb40-503"><a href="#cb40-503" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-504"><a href="#cb40-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-507"><a href="#cb40-507" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb40-508"><a href="#cb40-508" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb40-509"><a href="#cb40-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-510"><a href="#cb40-510" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, title<span class="op">=</span><span class="st">"Source Image"</span>)</span>
<span id="cb40-511"><a href="#cb40-511" aria-hidden="true" tabindex="-1"></a>ax1.imshow(X_src, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-512"><a href="#cb40-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-513"><a href="#cb40-513" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($\sigma=0.05$)"</span>)</span>
<span id="cb40-514"><a href="#cb40-514" aria-hidden="true" tabindex="-1"></a>ax2.imshow(fit_smooth.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-515"><a href="#cb40-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-516"><a href="#cb40-516" aria-hidden="true" tabindex="-1"></a>ax3 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($\sigma=1$)"</span>)</span>
<span id="cb40-517"><a href="#cb40-517" aria-hidden="true" tabindex="-1"></a>ax3.imshow(fit.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-518"><a href="#cb40-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-519"><a href="#cb40-519" aria-hidden="true" tabindex="-1"></a>ax4 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, title<span class="op">=</span><span class="st">"Recovered Image</span><span class="ch">\n</span><span class="st">($\sigma=20$)"</span>)</span>
<span id="cb40-520"><a href="#cb40-520" aria-hidden="true" tabindex="-1"></a>ax4.imshow(fit_rougher.stan_variable(<span class="st">"X"</span>), cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb40-521"><a href="#cb40-521" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-522"><a href="#cb40-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-523"><a href="#cb40-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-524"><a href="#cb40-524" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb40-525"><a href="#cb40-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-526"><a href="#cb40-526" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb40-527"><a href="#cb40-527" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb40-528"><a href="#cb40-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-529"><a href="#cb40-529" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendicies {.unnumbered}</span></span>
<span id="cb40-530"><a href="#cb40-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-531"><a href="#cb40-531" aria-hidden="true" tabindex="-1"></a><span class="fu"># Full Stan Code {#full-code .appendix}</span></span>
<span id="cb40-532"><a href="#cb40-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-533"><a href="#cb40-533" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-534"><a href="#cb40-534" aria-hidden="true" tabindex="-1"></a><span class="in">{{&lt; include holoml.stan &gt;}}</span></span>
<span id="cb40-535"><a href="#cb40-535" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-536"><a href="#cb40-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-537"><a href="#cb40-537" aria-hidden="true" tabindex="-1"></a><span class="fu">## Digression: Efficiency</span></span>
<span id="cb40-538"><a href="#cb40-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-539"><a href="#cb40-539" aria-hidden="true" tabindex="-1"></a>The model above is coded for readability and sticks closely to the mathematical formulation of the process. However, this does lead to an inefficient condition inside the tightest loop of the model to handle the beamstop occlusion.</span>
<span id="cb40-540"><a href="#cb40-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-541"><a href="#cb40-541" aria-hidden="true" tabindex="-1"></a>In practice, it is possible to avoid this conditional by changing how the data is stored. Instead of storing the beamstop occlusion as a parallel matrix, we can pre-compute the list of indices which are included once and store it. Then, we can create flat representations of both the data $\tilde{Y}$ and the rate $\lambda$, allowing us to use a vectorized version of the Poisson distribution.</span>
<span id="cb40-542"><a href="#cb40-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-543"><a href="#cb40-543" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb40-544"><a href="#cb40-544" aria-hidden="true" tabindex="-1"></a><span class="in">transformed data {</span></span>
<span id="cb40-545"><a href="#cb40-545" aria-hidden="true" tabindex="-1"></a><span class="in">  array[M1, M2] int B_cal = beamstop_gen(M1, M2, r);</span></span>
<span id="cb40-546"><a href="#cb40-546" aria-hidden="true" tabindex="-1"></a><span class="in">  int total = sum(to_array_1d(B_cal));</span></span>
<span id="cb40-547"><a href="#cb40-547" aria-hidden="true" tabindex="-1"></a><span class="in">  array[total, 2] idxs;</span></span>
<span id="cb40-548"><a href="#cb40-548" aria-hidden="true" tabindex="-1"></a><span class="in">  // pre-compute indices</span></span>
<span id="cb40-549"><a href="#cb40-549" aria-hidden="true" tabindex="-1"></a><span class="in">  int current = 1;</span></span>
<span id="cb40-550"><a href="#cb40-550" aria-hidden="true" tabindex="-1"></a><span class="in">  for (n in 1:M1){</span></span>
<span id="cb40-551"><a href="#cb40-551" aria-hidden="true" tabindex="-1"></a><span class="in">    for (m in 1:M2){</span></span>
<span id="cb40-552"><a href="#cb40-552" aria-hidden="true" tabindex="-1"></a><span class="in">      if (B_cal[n, m]){</span></span>
<span id="cb40-553"><a href="#cb40-553" aria-hidden="true" tabindex="-1"></a><span class="in">        idxs[current, :] = {n,m};</span></span>
<span id="cb40-554"><a href="#cb40-554" aria-hidden="true" tabindex="-1"></a><span class="in">        current += 1;</span></span>
<span id="cb40-555"><a href="#cb40-555" aria-hidden="true" tabindex="-1"></a><span class="in">      }</span></span>
<span id="cb40-556"><a href="#cb40-556" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb40-557"><a href="#cb40-557" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-558"><a href="#cb40-558" aria-hidden="true" tabindex="-1"></a><span class="in">  // flatten data accordingly</span></span>
<span id="cb40-559"><a href="#cb40-559" aria-hidden="true" tabindex="-1"></a><span class="in">  array[total] int&lt;lower=0&gt; Ys;</span></span>
<span id="cb40-560"><a href="#cb40-560" aria-hidden="true" tabindex="-1"></a><span class="in">  for (n in 1:total) {</span></span>
<span id="cb40-561"><a href="#cb40-561" aria-hidden="true" tabindex="-1"></a><span class="in">    Ys[n] = Y_tilde[idxs[n, 1], idxs[n, 2]];</span></span>
<span id="cb40-562"><a href="#cb40-562" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-563"><a href="#cb40-563" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb40-564"><a href="#cb40-564" aria-hidden="true" tabindex="-1"></a><span class="in">model {</span></span>
<span id="cb40-565"><a href="#cb40-565" aria-hidden="true" tabindex="-1"></a><span class="in">  // ... same code for computing matrix[M1, M2] lambda here</span></span>
<span id="cb40-566"><a href="#cb40-566" aria-hidden="true" tabindex="-1"></a><span class="in">  array[total] real lambdas;</span></span>
<span id="cb40-567"><a href="#cb40-567" aria-hidden="true" tabindex="-1"></a><span class="in">  for (n in 1:total) {</span></span>
<span id="cb40-568"><a href="#cb40-568" aria-hidden="true" tabindex="-1"></a><span class="in">    lambdas[n] = lambda[idxs[n, i], idxs[n, j]];  // much cheaper than branching</span></span>
<span id="cb40-569"><a href="#cb40-569" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb40-570"><a href="#cb40-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-571"><a href="#cb40-571" aria-hidden="true" tabindex="-1"></a><span class="in">  Ys ~ poisson(lambdas);  // fully vectorized</span></span>
<span id="cb40-572"><a href="#cb40-572" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb40-573"><a href="#cb40-573" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb40-574"><a href="#cb40-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-575"><a href="#cb40-575" aria-hidden="true" tabindex="-1"></a>This formulation of the model reduces the amount of time per gradient evaluation by 15-20%. A brief evaluation suggests however that the impact on optimization runtime is minimal.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>