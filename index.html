<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brian Ward">
<meta name="author" content="Bob Carpenter">
<meta name="author" content="David Barmherzig">
<meta name="dcterms.date" content="2024-08-14">
<meta name="keywords" content="Stan, coherent-diffraction-imaging, statistics, bayesian, phase-retrieval, inverse-problem <br /> <br />">

<title>Estimation and Sampling for Holographic Coherent Diffraction Imaging</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="HoloCDI_files/libs/clipboard/clipboard.min.js"></script>
<script src="HoloCDI_files/libs/quarto-html/quarto.js"></script>
<script src="HoloCDI_files/libs/quarto-html/popper.min.js"></script>
<script src="HoloCDI_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="HoloCDI_files/libs/quarto-html/anchor.min.js"></script>
<link href="HoloCDI_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="HoloCDI_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="HoloCDI_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="HoloCDI_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="HoloCDI_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>
<meta name="quarto:status" content="draft">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Estimation and Sampling for Holographic Coherent Diffraction Imaging</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">Low-photon phase retrieval with MLE, MAP, VB, and MCMC</p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliation</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://brianward.dev/">Brian Ward</a> <a href="https://orcid.org/0000-0002-9841-3342" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/">
                  Flatiron Institute
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://bob-carpenter.github.io/">Bob Carpenter</a> <a href="https://orcid.org/0000-0002-2433-9688" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/">
                  Flatiron Institute
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://davidbar.org/">David Barmherzig</a> <a href="https://orcid.org/0000-0003-2466-981X" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/">
                  Flatiron Institute
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 14, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">August 14, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Stan, coherent-diffraction-imaging, statistics, bayesian, phase-retrieval, inverse-problem <br> <br></p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>This case study provides a forward statistical model for holographic coherent diffraction imaging (Holo CDI) that generates a random photon flux from an image and explores several ways of solving the inverse problem (i.e., recovering the image from the measured flux). Maximum a posteriori estimates (MAP) and penalized maximum likelihood estimates (MLE) are provided by limited memory quasi-Newton optimization (L-BFGS). Variational Bayes (VB) is implemented with Pathfinder. Markov chain Monte Carlo (MCMC) is implemented with the no-U-turn sampler (NUTS). Evaluations include log density, root mean square error (RMSE), and the image-specific measures structural similarity (SSIM) and and peak signal-to-noise ratio (PSNR).</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a>
  <ul class="collapse">
  <li><a href="#python-boilerplate" id="toc-python-boilerplate" class="nav-link" data-scroll-target="#python-boilerplate"><span class="header-section-number">1.1</span> Python boilerplate</a></li>
  </ul></li>
  <li><a href="#test-images" id="toc-test-images" class="nav-link" data-scroll-target="#test-images"><span class="header-section-number">2</span> Test images</a>
  <ul class="collapse">
  <li><a href="#primary-test-image" id="toc-primary-test-image" class="nav-link" data-scroll-target="#primary-test-image"><span class="header-section-number">2.1</span> Primary test image</a></li>
  <li><a href="#secondary-test-images" id="toc-secondary-test-images" class="nav-link" data-scroll-target="#secondary-test-images"><span class="header-section-number">2.2</span> Secondary test images</a></li>
  </ul></li>
  <li><a href="#the-generative-model" id="toc-the-generative-model" class="nav-link" data-scroll-target="#the-generative-model"><span class="header-section-number">3</span> The generative model</a>
  <ul class="collapse">
  <li><a href="#image-and-photon-sensor-representations" id="toc-image-and-photon-sensor-representations" class="nav-link" data-scroll-target="#image-and-photon-sensor-representations"><span class="header-section-number">3.1</span> Image and photon sensor representations</a></li>
  <li><a href="#unconstrained-representation-and-change-of-variables-correction" id="toc-unconstrained-representation-and-change-of-variables-correction" class="nav-link" data-scroll-target="#unconstrained-representation-and-change-of-variables-correction"><span class="header-section-number">3.2</span> Unconstrained representation and change of variables correction</a></li>
  <li><a href="#generative-process-overview" id="toc-generative-process-overview" class="nav-link" data-scroll-target="#generative-process-overview"><span class="header-section-number">3.3</span> Generative process overview</a></li>
  <li><a href="#the-prior" id="toc-the-prior" class="nav-link" data-scroll-target="#the-prior"><span class="header-section-number">3.4</span> The prior</a>
  <ul class="collapse">
  <li><a href="#uniform-prior-is-possible" id="toc-uniform-prior-is-possible" class="nav-link" data-scroll-target="#uniform-prior-is-possible"><span class="header-section-number">3.4.1</span> Uniform prior is possible</a></li>
  <li><a href="#icar-prior-in-constrained-space" id="toc-icar-prior-in-constrained-space" class="nav-link" data-scroll-target="#icar-prior-in-constrained-space"><span class="header-section-number">3.4.2</span> ICAR prior in constrained space</a></li>
  <li><a href="#icar-prior-in-unconstrained-space" id="toc-icar-prior-in-unconstrained-space" class="nav-link" data-scroll-target="#icar-prior-in-unconstrained-space"><span class="header-section-number">3.4.3</span> ICAR prior in unconstrained space</a></li>
  </ul></li>
  <li><a href="#the-sampling-distribution" id="toc-the-sampling-distribution" class="nav-link" data-scroll-target="#the-sampling-distribution"><span class="header-section-number">3.5</span> The sampling distribution</a>
  <ul class="collapse">
  <li><a href="#the-reference-image" id="toc-the-reference-image" class="nav-link" data-scroll-target="#the-reference-image"><span class="header-section-number">3.5.1</span> The reference image</a></li>
  <li><a href="#the-seperator-and-reference-image" id="toc-the-seperator-and-reference-image" class="nav-link" data-scroll-target="#the-seperator-and-reference-image"><span class="header-section-number">3.5.2</span> The seperator and reference image</a></li>
  <li><a href="#padding" id="toc-padding" class="nav-link" data-scroll-target="#padding"><span class="header-section-number">3.5.3</span> Padding</a></li>
  <li><a href="#fourier-transform-shift" id="toc-fourier-transform-shift" class="nav-link" data-scroll-target="#fourier-transform-shift"><span class="header-section-number">3.5.4</span> Fourier transform shift</a></li>
  <li><a href="#fourier-transform" id="toc-fourier-transform" class="nav-link" data-scroll-target="#fourier-transform"><span class="header-section-number">3.5.5</span> Fourier transform</a></li>
  <li><a href="#beamstop" id="toc-beamstop" class="nav-link" data-scroll-target="#beamstop"><span class="header-section-number">3.5.6</span> Beamstop</a></li>
  <li><a href="#normalization" id="toc-normalization" class="nav-link" data-scroll-target="#normalization"><span class="header-section-number">3.5.7</span> Normalization</a></li>
  <li><a href="#poisson-photon-sampling" id="toc-poisson-photon-sampling" class="nav-link" data-scroll-target="#poisson-photon-sampling"><span class="header-section-number">3.5.8</span> Poisson photon sampling</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#stan-programs" id="toc-stan-programs" class="nav-link" data-scroll-target="#stan-programs"><span class="header-section-number">4</span> Stan programs</a>
  <ul class="collapse">
  <li><a href="#the-data-declaration" id="toc-the-data-declaration" class="nav-link" data-scroll-target="#the-data-declaration"><span class="header-section-number">4.1</span> The data declaration</a></li>
  <li><a href="#transformed-data" id="toc-transformed-data" class="nav-link" data-scroll-target="#transformed-data"><span class="header-section-number">4.2</span> Transformed data</a></li>
  <li><a href="#parameter-declaration" id="toc-parameter-declaration" class="nav-link" data-scroll-target="#parameter-declaration"><span class="header-section-number">4.3</span> Parameter declaration</a></li>
  <li><a href="#the-model-block" id="toc-the-model-block" class="nav-link" data-scroll-target="#the-model-block"><span class="header-section-number">4.4</span> The model block</a></li>
  <li><a href="#alternative-unconstrained-model" id="toc-alternative-unconstrained-model" class="nav-link" data-scroll-target="#alternative-unconstrained-model"><span class="header-section-number">4.5</span> Alternative unconstrained model</a></li>
  </ul></li>
  <li><a href="#estimation-and-posterior-inference" id="toc-estimation-and-posterior-inference" class="nav-link" data-scroll-target="#estimation-and-posterior-inference"><span class="header-section-number">5</span> Estimation and Posterior Inference</a>
  <ul class="collapse">
  <li><a href="#compiling-the-models" id="toc-compiling-the-models" class="nav-link" data-scroll-target="#compiling-the-models"><span class="header-section-number">5.1</span> Compiling the models</a></li>
  <li><a href="#constructing-the-data-dictionary" id="toc-constructing-the-data-dictionary" class="nav-link" data-scroll-target="#constructing-the-data-dictionary"><span class="header-section-number">5.2</span> Constructing the data dictionary</a></li>
  <li><a href="#optimization-based-point-estimates" id="toc-optimization-based-point-estimates" class="nav-link" data-scroll-target="#optimization-based-point-estimates"><span class="header-section-number">5.3</span> Optimization-based point estimates</a>
  <ul class="collapse">
  <li><a href="#penalized-maximum-likelihood-estimation" id="toc-penalized-maximum-likelihood-estimation" class="nav-link" data-scroll-target="#penalized-maximum-likelihood-estimation"><span class="header-section-number">5.3.1</span> Penalized maximum likelihood estimation</a></li>
  <li><a href="#maximum-a-posteriori-estimation" id="toc-maximum-a-posteriori-estimation" class="nav-link" data-scroll-target="#maximum-a-posteriori-estimation"><span class="header-section-number">5.3.2</span> Maximum a posteriori estimation</a></li>
  <li><a href="#mle-and-map-for-unconstrained-model" id="toc-mle-and-map-for-unconstrained-model" class="nav-link" data-scroll-target="#mle-and-map-for-unconstrained-model"><span class="header-section-number">5.3.3</span> MLE and MAP for unconstrained model</a></li>
  <li><a href="#visualizing-the-optimization-based-fits" id="toc-visualizing-the-optimization-based-fits" class="nav-link" data-scroll-target="#visualizing-the-optimization-based-fits"><span class="header-section-number">5.3.4</span> Visualizing the optimization-based fits</a></li>
  </ul></li>
  <li><a href="#effect-of-prior-scale" id="toc-effect-of-prior-scale" class="nav-link" data-scroll-target="#effect-of-prior-scale"><span class="header-section-number">5.4</span> Effect of prior scale</a></li>
  <li><a href="#bayesian-estimates-and-samples" id="toc-bayesian-estimates-and-samples" class="nav-link" data-scroll-target="#bayesian-estimates-and-samples"><span class="header-section-number">5.5</span> Bayesian estimates and samples</a>
  <ul class="collapse">
  <li><a href="#variational-inference" id="toc-variational-inference" class="nav-link" data-scroll-target="#variational-inference"><span class="header-section-number">5.5.1</span> Variational inference</a></li>
  <li><a href="#markov-chain-monte-carlo" id="toc-markov-chain-monte-carlo" class="nav-link" data-scroll-target="#markov-chain-monte-carlo"><span class="header-section-number">5.5.2</span> Markov-chain Monte Carlo</a></li>
  <li><a href="#plotting-mcmc-derived-fits" id="toc-plotting-mcmc-derived-fits" class="nav-link" data-scroll-target="#plotting-mcmc-derived-fits"><span class="header-section-number">5.5.3</span> Plotting MCMC-derived fits</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#appendicies" id="toc-appendicies" class="nav-link" data-scroll-target="#appendicies">Appendicies</a></li>
  
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Coherent diffraction imaging (CDI) is a technique for imaging nanoscale biomolecules such as macroviruses and proteins. CDI involves exposing the object being imaged to a coherent beam of X-rays and measuring the diffracted photon flux at a sensor placed behind the object being imaged. The diffraction pattern theoretically follows a Fourier transform, but only the squared magnitude is observed, which induces a phase-retrieval problem where the real and imaginary components of the complex variables must be inferred so that the process may be inverted to form an image. Solving the inverse problem for CDI is highly challenging and typically lacks a unique solution <span class="citation" data-cites="barnett2020">(<a href="#ref-barnett2020" role="doc-biblioref">Barnett et al. 2020</a>)</span>.</p>
<p>Holographic coherent diffraction imaging (HCDI) is a variant of CDI in which the specimen is placed some distance away from a known reference object, and the data observed is the pattern of diffraction around both the specimen and the reference. The addition of a reference object reduces the inverse problem to a linear deconvolution problem which has a unique, closed-form solution in the idealized setting <span class="citation" data-cites="barmherzig2019">(<a href="#ref-barmherzig2019" role="doc-biblioref">Barmherzig et al. 2019</a>)</span>.</p>
<p>In this note, we follow <span class="citation" data-cites="barmherzig2022">Barmherzig and Sun (<a href="#ref-barmherzig2022" role="doc-biblioref">2022</a>)</span> in defining a forward statistical model that, given the image being reconstructed, defines the expected photon flux at the sensors in terms of the Fourier transform of the image and Poisson sampling of incident photons. Starting from the model of <span class="citation" data-cites="barmherzig2022">Barmherzig and Sun (<a href="#ref-barmherzig2022" role="doc-biblioref">2022</a>)</span>, we add an intrinsic conditional autoregressive (ICAR) prior on the image which can be used to control smoothing of adjacent pixels <span class="citation" data-cites="besag1991">(<a href="#ref-besag1991" role="doc-biblioref">Besag, York, and Mollié 1991</a>)</span>. We then log-odds (logit) transform the parameters of the model, which represent pixel intensity between 0 and 1, into unconstrained variables so the model has support on all of <span class="math inline">\mathbb{R}^{M \times N}</span> for an <span class="math inline">M \times N</span> pixel image.</p>
<p>The forward model of holographic CDI defines a sampling distribution for the observed photon flux. When combined with a prior, the forward model induces an inverse problem whereby we measure photon flux on a grid of sensors and infer the image that caused it. We will explore the following standard algorithms for exact and approximate solution of the inverse problem.</p>
<ul>
<li>Penalized maxmum likelihood (MLE): Solve with optimization, do not adjust for unconstraining transform.</li>
<li>Maximum a posteriori (MAP): Solve with optimization, adjusting for the unconstraining transform.</li>
<li>Variational Bayes (VB): Solve by minimizing Kullback-Leibler divergence from an approximate posterior to the true posterior and importance resampling.</li>
<li>Markov chain Monte Carlo (MCMC): Solve by sampling from the posterior and averaging.</li>
</ul>
<p>Computationally, we will code the models using Stan <span class="citation" data-cites="carpenter2017">(<a href="#ref-carpenter2017" role="doc-biblioref">Carpenter et al. 2017</a>)</span>, a probabilistic programming language for expressing differentiable log densities. All that is needed to solve the inverse problem with Stan is a program implementing the forward model’s log density. Stan uses derivative-based methods for optimization, sampling, and variational inference in order to scale with dimension. It also contains a comprehensive suite of posterior analysis tools for summarizing fits to data.</p>
<p><span class="citation" data-cites="barmherzig2022">Barmherzig and Sun (<a href="#ref-barmherzig2022" role="doc-biblioref">2022</a>)</span> used two different optimizers for maximum likelihood inference, conjugate gradient and trust regions. We will employ limited memory quasi-Newton optimization in the form of the limited-memory BFGS (L-BFGS) optimizer <span class="citation" data-cites="zhu1997">(<a href="#ref-zhu1997" role="doc-biblioref">Zhu et al. 1997</a>)</span>, which tends to outperform both conjugate gradient and trust-region methods for relatively simple optimization problems in moderately high dimensions like this one. If the model adjusts for the inverse log odds (logistic) transform, the optimizer produces a maximum a posteriori (MAP) estimate, whereas if the model does not adjust for the change of variables, the optimizer produces a penalized maximum likelihood estimate (MLE). <!-- BMW: seems repetitive with above bulleted list? --></p>
<p>We employ two different Bayesian methods for solving the inverse problem, variational Bayes (VB) and Markov chain Monte Carlo (MCMC) sampling. For MCMC, we employ the no-U-turn sampler (NUTS) <span class="citation" data-cites="hoffman2014">(<a href="#ref-hoffman2014" role="doc-biblioref">Hoffman, Gelman, et al. 2014</a>)</span>, which is an adaptive form of Hamiltonian Monte Carlo (HMC). With MCMC, the result is an exact posterior sampler for which estimation error goes to zero as sample size goes to infinity. For variational Bayes, we employ Pathfinder <span class="citation" data-cites="zhang2022">(<a href="#ref-zhang2022" role="doc-biblioref">Zhang et al. 2022</a>)</span>. With VB, the results are only approximate, and in particular, posterior uncertainty tends to be systematically underestimated because we minimize KL-divergence from the approximation to the target distribution.</p>
<section id="python-boilerplate" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="python-boilerplate"><span class="header-section-number">1.1</span> Python boilerplate</h2>
<p>Generating the data requires the standard Python numerical libraries <code>scipy.stats</code> and <code>numpy</code>, as well as the plotting libraries <code>matplotlib</code> and <code>plotnine</code> to display results. Stan is accessed through the <code>cmdstanpy</code> interface. There is also code for converting RGB-coded images to grayscale.</p>
<div id="eca694df" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmdstanpy <span class="im">as</span> csp</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.image <span class="im">as</span> mpimg</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotnine <span class="im">as</span> pn</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># turn off warning and info messages from Stan</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>csp.utils.get_logger().setLevel(logging.ERROR)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># turn off warnings from plotnine</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>warnings.simplefilter(action<span class="op">=</span><span class="st">'ignore'</span>, category<span class="op">=</span><span class="pp">FutureWarning</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings( <span class="st">"ignore"</span>, module <span class="op">=</span> <span class="st">"plotnine\..*"</span> )</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rgb2gray(rgb):</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert a nxmx3 RGB array to a grayscale nxm array.</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">    This function uses the same internal coefficients as MATLAB:</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">    https://www.mathworks.com/help/matlab/ref/rgb2gray.html</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    r, g, b <span class="op">=</span> rgb[:, :, <span class="dv">0</span>], rgb[:, :, <span class="dv">1</span>], rgb[:, :, <span class="dv">2</span>]</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    gray <span class="op">=</span> <span class="fl">0.2989</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.5870</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.1140</span> <span class="op">*</span> b</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gray</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="test-images" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Test images</h1>
<p>For simplicity of exposition, we will restrict attention to black and white digital images at <span class="math inline">256 \times 256</span> pixel resolution. The pixel values will be represented with continuous values in <span class="math inline">[0, 1]</span>, with <span class="math inline">0</span> being pure black and <span class="math inline">1</span> pure white. An image is thus an element <span class="math inline">X \in [0, 1]^{256 \times 256}.</span> Compute time to evaluate the log density and gradients scales linearly in time and memory for each image dimension, which means it scales quadratically in <span class="math inline">N</span> for an <span class="math inline">N \times N</span> image.</p>
<section id="primary-test-image" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="primary-test-image"><span class="header-section-number">2.1</span> Primary test image</h2>
<p>We will concentrate on the target image of a <a href="https://en.wikipedia.org/wiki/Mimivirus">mimivirus</a>, a type of <a href="https://en.wikipedia.org/wiki/Giant_virus">giant virus</a>. It is giant in the sense that its genome is over one million base pairs in length. The mimivirus is structured as an icosahedral capsid of approximately 400nm with filaments extending another 100nm around the capsid. An image is shown in <a href="#fig-mimivirus" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div id="cell-fig-mimivirus" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>X_src <span class="op">=</span> rgb2gray(mpimg.imread(<span class="st">'img/mimivirus.png'</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_src, cmap<span class="op">=</span><span class="st">'gray'</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-mimivirus" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mimivirus-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-mimivirus-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mimivirus-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Image of a mimivirus. The capsid is an icosahedron 400nm across with 100nm filaments. Image copyright 2008 by E. Ghigo J. Kartenbeck, P. Lien, L. Pelkmans, C. Capo, J.L. Mege, and D. Raoult D. 2008, and distributed under the <a href="https://creativecommons.org/licenses/by/2.5">CC BY 2.5</a> license.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="secondary-test-images" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="secondary-test-images"><span class="header-section-number">2.2</span> Secondary test images</h2>
<!-- BMW: are these still planned? -->
<p>In addition to the mimivirus image, we will also simulate and reconstruct the ten images show in <a href="#fig-test_img" class="quarto-xref">Figure&nbsp;2</a>.</p>
<div id="cell-fig-test_img" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>img_dir <span class="op">=</span> <span class="st">'img/usc-sipi'</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>image_files <span class="op">=</span> <span class="bu">sorted</span>([f <span class="cf">for</span> f <span class="kw">in</span> os.listdir(img_dir) <span class="cf">if</span> f.endswith(<span class="st">'.png'</span>)])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">8</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>axs <span class="op">=</span> axs.ravel()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axs):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    img_path <span class="op">=</span> os.path.join(img_dir, image_files[i])</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    gray_img <span class="op">=</span> mpimg.imread(img_path)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    ax.imshow(gray_img, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-test_img" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-test_img-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-test_img-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-test_img-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Images form the USC/SIPI test repository. First row, left to right) female [Bell Labs?], house, tree, jelly beans, moon surface. Second row, left to right) aerial, airplane, clock, resolution chart, chemical plant.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="the-generative-model" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> The generative model</h1>
<section id="image-and-photon-sensor-representations" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="image-and-photon-sensor-representations"><span class="header-section-number">3.1</span> Image and photon sensor representations</h2>
<p>An image is represented by a random matrix of continuous pixel values between 0 and 1, <span class="math inline">X \in [0, 1]^{N \times N}</span>. Typically we will be using a representation that excludes the endpoints other than through numerical underflow or rounding. <!-- BMW: should we be re-quantizing our images do we think? --> The photons measured at the sensor are represented by a random matrix of discrete counts for the sensor grid, <span class="math inline">Y \in \mathbb{N}^{M_1 \times M_2}.</span></p>
</section>
<section id="unconstrained-representation-and-change-of-variables-correction" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="unconstrained-representation-and-change-of-variables-correction"><span class="header-section-number">3.2</span> Unconstrained representation and change of variables correction</h2>
<p>It is more convenient for both sampling and optimization to work over an unconstrained parameterization with support in all of <span class="math inline">\mathbb{R}^D</span> for some <span class="math inline">D.</span> As an alternative to the constrained image representation <span class="math inline">X</span>, consider the smooth, bijective, and strictly monotonic log odds transform applied elementwise, <span class="math display">\begin{equation}
U = \textrm{logit}(X),
\end{equation}</span> where <span class="math display">\begin{equation}
\textrm{logit}(v) = \log \left( \frac{v}{1 - v} \right)
\qquad
\textrm{logit}^{-1}(u) = \frac{1}{1 + \exp(-u)}.
\end{equation}</span> If <span class="math inline">p_X</span> has support on <span class="math inline">(0, 1)^{N \times N},</span> then <span class="math inline">p_U</span> has support on all of <span class="math inline">\mathbb{R}^{N \times N}.</span> The density of <span class="math inline">U</span> is given by the change of variables formula, <span class="math display">\begin{equation}
p_U(u) = p_X(\textrm{logit}^{-1}(u)) \cdot \left| \prod_{i, j} (\textrm{logit}^{-1})'(u_{i,j}) \right|,
\end{equation}</span> where the derivative of the logistic sigmoid <span class="math inline">\textrm{logit}^{-1}</span> is <span class="math display">\begin{equation}
\left(\textrm{logit}^{-1}\right)'(u)
= \textrm{logit}^{-1}(u) \cdot \left( 1 - \textrm{logit}^{-1}(u) \right).
\end{equation}</span> On the log scale, <span class="math display">\begin{equation}
\log p_U(u) = \log p_X(\textrm{logit}^{-1}(u))
+ \sum_{i, j} \log \left( (\textrm{logit}^{-1})'(u_{i,j}) \right).
\end{equation}</span></p>
</section>
<section id="generative-process-overview" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="generative-process-overview"><span class="header-section-number">3.3</span> Generative process overview</h2>
<p>The first step is to generate an image from the prior, <span class="math display">\begin{equation}
x \sim p_X\,(\cdot).
\end{equation}</span> Then, given the image <span class="math inline">x</span>, the second and final step is to generate the photons observed at the sensors <span class="math inline">y</span> conditioned on the image <span class="math inline">x,</span> using the sampling distribution, <span class="math display">\begin{equation}
y \sim p_{Y \mid X}\,(\cdot \mid x).
\end{equation}</span></p>
</section>
<section id="the-prior" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="the-prior"><span class="header-section-number">3.4</span> The prior</h2>
<section id="uniform-prior-is-possible" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="uniform-prior-is-possible"><span class="header-section-number">3.4.1</span> Uniform prior is possible</h3>
<p>Because the space <span class="math inline">[0, 1]^{256 \times 256}</span> has finite hypervolume, it would be possible to use a uniform prior over pixel values, <span class="math inline">p_X(x) \propto 1.</span> At the other extreme, it would also be possible to introduce a meaningful natural image prior <span class="citation" data-cites="kadkhodaie2021">(<a href="#ref-kadkhodaie2021" role="doc-biblioref">Kadkhodaie and Simoncelli 2021</a>)</span>, a promising modern approach to which is based on diffusion models <span class="citation" data-cites="graikos2022 fei2023">(<a href="#ref-graikos2022" role="doc-biblioref">Graikos et al. 2022</a>; <a href="#ref-fei2023" role="doc-biblioref">Fei et al. 2023</a>)</span>.</p>
</section>
<section id="icar-prior-in-constrained-space" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="icar-prior-in-constrained-space"><span class="header-section-number">3.4.2</span> ICAR prior in constrained space</h3>
<p>Instead of a uniform prior or natural image prior, we will use a simple intrinsic conditional autoregressive (ICAR) prior <span class="citation" data-cites="besag1991">(<a href="#ref-besag1991" role="doc-biblioref">Besag, York, and Mollié 1991</a>)</span>, which penalizes differences between adjacent pixels according to a scale <span class="math inline">\sigma &gt; 0.</span> These priors were originally developed for image denoising. The ICAR prior is defined by <span class="math display">\begin{equation}
p_X(x) \propto \prod_{(m, n) \sim (m', n')} \textrm{normal}(x_{m,n} \mid x_{m',n'}, \ \sigma),
\end{equation}</span> where <span class="math inline">\sim</span> is the adjacency relationship defined to be unique so that <span class="math inline">(m, n) \sim (m + 1, n)</span> for <span class="math inline">m &lt; 256</span> and <span class="math inline">(m, n) \sim (m, n + 1)</span> for <span class="math inline">n &lt; 256</span>, and where <span class="math inline">\sigma</span> is the scale of the normal distribution. This density <span class="math inline">p_X</span> can, in theory, be normalized within the space <span class="math inline">[0, 1]^{256 \times 256},</span> but that is not going to be necessary for any of the inference methods we use. It would also be possible to smooth along the diagonals by including an adjacency relation <span class="math inline">(m, n) \sim (m + 1, n + 1)</span> for <span class="math inline">m, n &lt; 256,</span> but we do not evaluate that option here.</p>
<p>Because we will be sampling using the unconstrained space <span class="math inline">U,</span> we apply the change of variables from <span class="math inline">X</span> to derive the density in the unconstrained space, <span class="math display">\begin{align}
p_U(u) \propto { } &amp;
\prod_{(m, n) \sim (m', n')}
\textrm{normal}\!\left(\textrm{logit}^{-1}(u_{m,n}) \mid \textrm{logit}^{-1}(u_{m',n'}), \ \sigma\right)
\\
&amp;
\hspace*{1em} \cdot \prod_{m, n} \textrm{logit}^{-1}(u_{m, n}) \cdot (1 - \textrm{logit}^{-1}(u_{m,n})).
\end{align}</span></p>
</section>
<section id="icar-prior-in-unconstrained-space" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="icar-prior-in-unconstrained-space"><span class="header-section-number">3.4.3</span> ICAR prior in unconstrained space</h3>
<p>An ICAR prior may also be placed directly on the unconstrained values, <span class="math display">\begin{equation}
p_U(u) \propto \prod_{(m, n) \sim (m', n')} \textrm{normal}(u_{m,n} \mid u_{m',n'}, \ \tau),
\end{equation}</span> with <span class="math inline">\tau</span> being the scale of variation of the unconstrained parameters. As before, <span class="math inline">X = \textrm{logit}^{-1}(u)</span> recovers the pixel values for use downstream in the model. Conveniently, when parameterized this way, the Jacobian adjustment is not necessary because a distribution is not being placed on the constrained parameters. This approach would not be feasible for natural image priors placed directly on <span class="math inline">X</span>.</p>
</section>
</section>
<section id="the-sampling-distribution" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="the-sampling-distribution"><span class="header-section-number">3.5</span> The sampling distribution</h2>
<p>The sampling distribution proceeds in several stages. First, the image is combined with a separator and a reference image and then padded. The result defines the shape of the sensor grid. Next, a discrete Fourier transform is applied to the padded and separated image and reference, the squared absolute values of which determine the proportion of photons that are expected to arrive at the specified sensor. Then a beamstop is applied to the model where it is applied in practice to prevent damage to the sample or sensors. Finally, the expected proportions are normalized for the intensity of the beam and then the photons are generated according to a simple Poisson process.</p>
<section id="the-reference-image" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="the-reference-image"><span class="header-section-number">3.5.1</span> The reference image</h3>
<p>For the experiments here, we use an idealized optimal reference image <span class="math inline">R</span>, the uniformly redundant array (URA) reference <span class="citation" data-cites="fenimore1978">(<a href="#ref-fenimore1978" role="doc-biblioref">Fenimore and Cannon 1978</a>)</span>; see <a href="#fig-ura" class="quarto-xref">Figure&nbsp;3</a>. The URA has been shown to be an optimal reference image for this kind of work. We use the <a href="https://github.com/bpops/codedapertures">codedapertures</a> package to generate a URA of appropriate size. The URA is black and white (i.e., no intermediate gray values), and it has the same dimensions (<span class="math inline">256 \times 256</span>) as the image being inferred. It will be supplied as data, so that other references can be swapped in depending on the actual reference image being used (e.g., a square cutout, a pinhole, or no reference at all).</p>
<div id="cell-fig-ura" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> codedapertures</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> codedapertures.ura(rank<span class="op">=</span><span class="dv">16</span>).aperture[:<span class="dv">256</span>,:<span class="dv">256</span>]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Uniformly Redundant Array
-------------------------
rank:   16
r, s:   271, 269
tile:   (1, 1)
width:  271
height: 269</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-ura" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ura-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-ura-output-2.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ura-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Uniformly redundant array. This reference image is optimal for identification through phase retrieval. Other reference images may be used with the same code and model.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="the-seperator-and-reference-image" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="the-seperator-and-reference-image"><span class="header-section-number">3.5.2</span> The seperator and reference image</h3>
<p>There is also a purely black separator of the same size as the image, which we will use <span class="math inline">Z</span> to denote because it is full of zero values. Like the reference pattern, this separator is typically chosen to be the same size as the specimen, so that its width <span class="math inline">d</span> is equal to <span class="math inline">N,</span> the pixel width of the image. The image <span class="math inline">X</span> will be concatenated left-to-right (i.e., by column) with the separator <span class="math inline">Z</span> and the reference image <span class="math inline">R</span>, and the result will be doenoted as <code>X_Z_R</code> in the code.</p>
<div id="cell-fig-separator" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> np.shape(X_src)[<span class="dv">0</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> N</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>X_Z_R <span class="op">=</span> np.concatenate([X_src, np.zeros((N, d)), R], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">3</span>))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_Z_R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">511</span>, <span class="dv">767</span>], [<span class="dv">1</span>, <span class="dv">256</span>, <span class="dv">512</span>, <span class="dv">768</span>])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-separator" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-separator-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-separator-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-separator-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Source image, zero separator, and reference image concatenated.
</figcaption>
</figure>
</div>
</div>
</div>
<p>It is this combination of image, separator, and reference are the ones subjected to a beam of X-rays.</p>
</section>
<section id="padding" class="level3" data-number="3.5.3">
<h3 data-number="3.5.3" class="anchored" data-anchor-id="padding"><span class="header-section-number">3.5.3</span> Padding</h3>
<p>The original image, separator and reference image are next padded to the right and below up to a size of <span class="math inline">M_1 \times M_2</span>. Sensors are placed at each position in the padded matrix. The padding has the effect of interpolating in image space. Let <span class="math display">\begin{equation}
P = \textrm{pad}(\textrm{cat}(X^{\textrm{src}}, Z, R), M_1, M_2)
\end{equation}</span> be the padded version of the image, separator, and reference image, where <span class="math inline">X^{\textrm{src}}</span> is the source image, <span class="math inline">Z</span> is a zero matrix, and <span class="math inline">R</span> is the reference image. The padding is taken to be twice the size of the material imaged, so that <span class="math inline">M_1 = 6 \cdot 256</span> and <span class="math inline">M_2 = 2 \cdot 256,</span> which brings the total number of sensors to 786,432, just shy of one megapixel. <!-- BMW: mention that padding can be smaller? see section 5 of @barmherzig2022 --></p>
</section>
<section id="fourier-transform-shift" class="level3" data-number="3.5.4">
<h3 data-number="3.5.4" class="anchored" data-anchor-id="fourier-transform-shift"><span class="header-section-number">3.5.4</span> Fourier transform shift</h3>
<p>Most fast Fourier transform (FFT) interfaces, including those in Stan, Matlab, and Python, return a shifted result with positive and negative values. Specifically, values increase in frequency until <span class="math inline">N,</span> at which point a mirror image copy with negative indexes is appended to the end. This produces the following order of indexes. <span class="math display">\begin{equation}
0, 1, \ldots, N, -N, -N + 1, \ldots, -1.
\end{equation}</span> To get centered values, these are circularly shifted until the lowest frequency, represented at position 0, is in the middle, <span class="math display">\begin{equation}
-N, -N + 1, \ldots -1, 0, 1, \ldots, N-1, N.
\end{equation}</span> With a two dimensional FFT, this happens twice, once for the rows and once for the columns. This results in a horizontal and vertical shift, which is why the <code>fftshift</code> operation swaps the diagonal blocks. This can be illustrated with the following code, which creates a matrix of distinct entries, shifts it, then inverse shifts it back. Assuming <span class="math inline">A, B, C, D</span> are matrices with conforming shapes (for building one big matrix), then <span class="math display">\begin{equation}
\textrm{fftshift}\left(
\begin{bmatrix}
A &amp; B
\\
C &amp; D
\end{bmatrix}
\right)
=
\begin{bmatrix}
D &amp; C
\\
B &amp; A
\end{bmatrix}
\end{equation}</span> The elements are swapped across the diagonals, or equivalently, cyclically rotated in the horizontal direction, then in the vertical direction. Consider the following concrete example matrix.</p>
<div id="85f69b27" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.ones((K, K), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        A[i, j] <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"A =</span><span class="ch">\n</span><span class="sc">{</span>A<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>A_shift <span class="op">=</span> np.fft.fftshift(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A =
[[ 0  1  2  3]
 [10 11 12 13]
 [20 21 22 23]
 [30 31 32 33]]
</code></pre>
</div>
</div>
<p>Shifting it produces the following shifted matrix, where the center elements move to the corners and vice-versa.</p>
<div id="23a340b1" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"fftshift(A) =</span><span class="ch">\n</span><span class="sc">{</span>A_shift<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>fftshift(A) =
[[22 23 20 21]
 [32 33 30 31]
 [ 2  3  0  1]
 [12 13 10 11]]
</code></pre>
</div>
</div>
<p>Shifting back returns the original matrix.</p>
<div id="9feeb024" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>A_shift_ishift <span class="op">=</span> np.fft.ifftshift(A_shift)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ifftshift(fftshift(A)) =</span><span class="ch">\n</span><span class="sc">{</span>A_shift_ishift<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>ifftshift(fftshift(A)) =
[[ 0  1  2  3]
 [10 11 12 13]
 [20 21 22 23]
 [30 31 32 33]]</code></pre>
</div>
</div>
</section>
<section id="fourier-transform" class="level3" data-number="3.5.5">
<h3 data-number="3.5.5" class="anchored" data-anchor-id="fourier-transform"><span class="header-section-number">3.5.5</span> Fourier transform</h3>
<p>The concatenated and padded image <span class="math inline">P</span> is next put through a discrete, two-dimensional fast Fourier transform (FFT), which produces a complex matix of values. These complex values, which have real and imaginary components, are then reduced to their real absolute value (aka magnitude). The complex absolute value is the hypoteneuse of their real and imaginary components, but the angle, or phase, is lost. This is why the problem of inferring the image from its Fourier transform is known as a phase-retrieval problem. The absolute value is then squared, resulting in a matrix of values that is proportional to the expected intensity of sensor readings given the image, separator, reference, and padding, <span class="math display">\begin{equation}
V = \big| \, \textrm{fft2}(P) \, \big|^2.
\end{equation}</span> <span class="math inline">P</span> has shape <span class="math inline">512 \times 1536,</span> so the two-dimensional FFT requires 1536 one-dimensional FFTs of size 512 and 512 one-dimensional FFTs of size 1536. <a href="#fig-fftout" class="quarto-xref">Figure&nbsp;5</a> shows a visualization of <span class="math inline">V</span>, after the FFT shift to center the low frequencies. The expected photon flux defines a lovely tartan pattern with horizontal and vertical reflection symmetries and a starburst in the center, which indicates the high expected photon flux in the low frequencies (which have been shifted to the center).</p>
<div id="cell-fig-fftout" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>M1 <span class="op">=</span> <span class="dv">256</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>M2 <span class="op">=</span> <span class="dv">256</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.fft2(X_Z_R, s<span class="op">=</span>(M1, M2)))<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>log1pV <span class="op">=</span> np.fft.fftshift(np.log1p(V))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>,<span class="dv">3</span>))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(log1pV, cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">767</span>, <span class="dv">1535</span>], [<span class="dv">1</span>, <span class="dv">768</span>, <span class="dv">1536</span>])</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">511</span>], [<span class="dv">1</span>, <span class="dv">256</span>, <span class="dv">512</span>])</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-fftout" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fftout-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-fftout-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fftout-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Squared magnitudes of the FFT of the concatenated and padded image. The low frequencies have been shifted to the center and the reflective symmetries show how the two-dimensional FFT has horizontal and vertical reflection symmetry. The bright spot in the middle shows the high expected photon flux in the low frequencies. The plot is scaled to <span class="math inline">\log (1 + V)</span> in order to display the pattern.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="beamstop" class="level3" data-number="3.5.6">
<h3 data-number="3.5.6" class="anchored" data-anchor-id="beamstop"><span class="header-section-number">3.5.6</span> Beamstop</h3>
<p>To prevent the coherent X-ray beam from destroying the sensors with high photon flux in the low frequencies, the frequency sensors are blocked with a beamstop. This blockage means zero photons arrive at sensors in the stopped positions. The image must be reconstructed from only the remaining sensors.</p>
<p>The beamstop has a configurable radius <span class="math inline">r</span> and occludes an <span class="math inline">(2 \cdot r - 1) \times (2 \cdot r - 1)</span> square of censors. These are placed at the low frequencies, which will be the center of the image when it is centered around zero. After the FFT shift is applied, the stopped regions move to the four corners (see the example in the previous section).</p>
<p>The shifted beamstop can be directly encoded as a matrix with zero values everywhere other than the 1 values in the the top left corner (<span class="math inline">r \times r</span> block), top right (<span class="math inline">r \times r - 1</span> block), lower left (<span class="math inline">r-1 \times r</span> block) and lower right (<span class="math inline">r - 1 \times r - 1</span> block). We will let <span class="math inline">\textrm{beamstop}_{i, j}</span> be equal to 1 if position <span class="math inline">(i, j)</span> is stopped (i.e., blocked) and 0 otherwise. When pieced together, that’s a <span class="math inline">(2 \cdot r - 1) \times (2 \cdot r - 1)</span> square that’s stopped. A plot of the beamstop is shown in <a href="#fig-beamstop" class="quarto-xref">Figure&nbsp;6</a>.</p>
<div id="cell-fig-beamstop" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>plot <span class="op">=</span> (</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  pn.ggplot()</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lower left</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">0</span>, xmax<span class="op">=</span><span class="dv">3</span>, ymin<span class="op">=</span><span class="dv">0</span>, ymax<span class="op">=</span><span class="dv">1</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lower right</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">9</span>, xmax<span class="op">=</span><span class="dv">12</span>, ymin<span class="op">=</span><span class="dv">0</span>, ymax<span class="op">=</span><span class="dv">1</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># upper left</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">0</span>, xmax<span class="op">=</span><span class="dv">3</span>, ymin<span class="op">=</span><span class="dv">3</span>, ymax<span class="op">=</span><span class="dv">4</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># upper right</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">9</span>, xmax<span class="op">=</span><span class="dv">12</span>, ymin<span class="op">=</span><span class="dv">3</span>, ymax<span class="op">=</span><span class="dv">4</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.scale_x_continuous(breaks<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">12</span>],</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>                          labels<span class="op">=</span>[<span class="st">"1"</span>, <span class="st">"r"</span>, <span class="st">"M1-r+2"</span>, <span class="st">"M1"</span>])</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.scale_y_continuous(breaks<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>],</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>                          labels<span class="op">=</span>[<span class="st">"1"</span>, <span class="st">"r"</span>, <span class="st">"M2-r+2"</span>, <span class="st">"M2"</span>])</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.theme(figure_size<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">2</span>),</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>             plot_background<span class="op">=</span>pn.element_rect(fill<span class="op">=</span><span class="st">"white"</span>),</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>             panel_background<span class="op">=</span>pn.element_rect(fill<span class="op">=</span><span class="st">"white"</span>),</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>             axis_title<span class="op">=</span>pn.element_blank(),</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>         axis_text_x<span class="op">=</span>pn.element_text(size<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">"black"</span>, angle<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>             axis_text_y<span class="op">=</span>pn.element_text(size<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">"black"</span>),</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>         axis_ticks<span class="op">=</span>pn.element_blank(),</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>         axis_line<span class="op">=</span>pn.element_blank(),</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>             <span class="co"># axis_ticks_length_major=5,</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>         <span class="co"># axis_line=pn.element_line(color="black"),</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>             panel_grid<span class="op">=</span>pn.element_blank())</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-beamstop" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-beamstop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-beamstop-output-1.png" class="quarto-figure quarto-figure-center figure-img" data-fig-pos="t" width="600" height="200">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-beamstop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Illustration of beamstop before the shifting. The solid blue rectangles occlude the low frequencies in the corners, so that photon flux is not measured at those positions.
</figcaption>
</figure>
</div>
</div>
</div>
<!-- BMW: I'd still like to see the plot that is figure 5 with the beamstop added, for contrast, unless you have a strong objection. -->
</section>
<section id="normalization" class="level3" data-number="3.5.7">
<h3 data-number="3.5.7" class="anchored" data-anchor-id="normalization"><span class="header-section-number">3.5.7</span> Normalization</h3>
<p>Let <span class="math inline">N_p</span> be the number of photons expected per sensor. This is used like an exposure value in a Poisson model to set the scale of the expected photon counts, which are given by the vector <span class="math inline">\lambda \in (0, \infty)^{M_1 \times M_2},</span> defined by <span class="math display">\begin{equation}
\lambda = \frac{N_p}{\textrm{mean}(V)} \cdot V.
\end{equation}</span></p>
</section>
<section id="poisson-photon-sampling" class="level3" data-number="3.5.8">
<h3 data-number="3.5.8" class="anchored" data-anchor-id="poisson-photon-sampling"><span class="header-section-number">3.5.8</span> Poisson photon sampling</h3>
<p>Finally, the number of photons observed at each sensor in the grid is generated as a Poisson distribution, based on the expected photon flux <span class="math inline">\lambda,</span> <span class="math display">\begin{equation}
Y_{i, j} \sim
\begin{cases}
\textrm{Poisson}(\lambda_{i, j}) &amp; \textrm{ if } \textrm{beamstop}(i, j) = 0
\\[4pt]
\textrm{Poisson}(0) &amp; \textrm{ if } \textrm{beamstop}(i, j) = 1.
\end{cases}
\end{equation}</span></p>
<p>A visualization of simulated <span class="math inline">Y</span> is shown (after being shifted) in <a href="#fig-simy" class="quarto-xref">Figure&nbsp;7</a>. The beamstop radius is set to <span class="math inline">r = 13,</span> so there is a <span class="math inline">25 \times 25</span> pixel square of sensors occluded by the beamstop.</p>
<div id="cell-fig-simy" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>shifted_beamstop <span class="op">=</span> np.ones((M1, M2))  <span class="co"># 0 values are occluded</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>shifted_beamstop[M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                 M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>beamstop <span class="op">=</span> np.fft.ifftshift(shifted_beamstop)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="dv">1</span>  <span class="co"># expected number of photons per sensor</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>lambbda <span class="op">=</span> N_p <span class="op">/</span> V.mean() <span class="op">*</span> V</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>preY <span class="op">=</span> sp.stats.poisson.rvs(lambbda, random_state<span class="op">=</span><span class="dv">1234</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> np.array(preY <span class="op">*</span> beamstop, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>log1pY <span class="op">=</span> np.log1p(Y)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>,<span class="dv">3</span>))</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.log1p(np.fft.fftshift(Y)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">767</span>, <span class="dv">1535</span>], [<span class="dv">1</span>, <span class="dv">768</span>, <span class="dv">1536</span>])</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">511</span>], [<span class="dv">1</span>, <span class="dv">256</span>, <span class="dv">512</span>])</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-simy" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-simy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-simy-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-simy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Sampled value of <span class="math inline">Y</span>, which is distributed Poisson with rate <span class="math inline">\lambda</span>. The effect of the beamstop can be seen in the <span class="math inline">25 \times 25</span> pixel black square in the center, indicating a flux of zero. The scaled matrix <span class="math inline">\log(1 + Y)</span> is shown.
</figcaption>
</figure>
</div>
</div>
</div>
<p>This completes the definition of the likelihood and with the prior, the forward model for simulating data.</p>
</section>
</section>
</section>
<section id="stan-programs" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Stan programs</h1>
<p>Stan is an imperative probabilistic programming langauge for statistical models coupled with tools for estimation and posterior analysis <span class="citation" data-cites="carpenter2017">(<a href="#ref-carpenter2017" role="doc-biblioref">Carpenter et al. 2017</a>)</span>. Stan’s <em>Reference Manual</em> <span class="citation" data-cites="standev2024ref">(<a href="#ref-standev2024ref" role="doc-biblioref">Stan Development Team 2024b</a>)</span> contains complete details and the <em>User’s Guide</em> <span class="citation" data-cites="standev2024users">(<a href="#ref-standev2024users" role="doc-biblioref">Stan Development Team 2024c</a>)</span> provides guidance on usage.</p>
<p>A Stan program defines the log posterior up to a normalizing constant, which is usually coded following Bayes’s rule as the log joint density, <span class="math display">\begin{equation}
\log p(x \mid y)
= \log p(y \mid x) + \log p(x) + \textrm{const},
\end{equation}</span> where <span class="math inline">x</span> is the vector of parameters representing the image and <span class="math inline">y</span> is the observed photon flux. It reads the data in and then produces a C++ class that can evaluate the log density and use automatic differentiation to define gradients and Hessians <span class="citation" data-cites="carpenter2015">(<a href="#ref-carpenter2015" role="doc-biblioref">Carpenter et al. 2015</a>)</span>. Stan’s inference algorithms are all gradient-based for efficiency and scalability in dimension. Stan is strongly statically typed, so all variables come with declarations of their type and size. Stan is an imperative language like R <span class="citation" data-cites="rteam2000">(<a href="#ref-rteam2000" role="doc-biblioref">R Core Team 2000</a>)</span> or Python <span class="citation" data-cites="vanrossum2010">(<a href="#ref-vanrossum2010" role="doc-biblioref">van Rossum and Drake 2010</a>)</span>, rather than a declarative language like BUGS <span class="citation" data-cites="lunn2013">(<a href="#ref-lunn2013" role="doc-biblioref">Lunn et al. 2013</a>)</span>, so variables other than parameters being inferred must be defined before they are used. Stan programs are organized into blocks for data, parameters, and the log density, plus transforms and predictive quantities. Initially, we will present the constrained model and then later show the few lines that need to change to define an unconstrained model. The full Stan programs are shown in the appendix.</p>
<section id="the-data-declaration" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="the-data-declaration"><span class="header-section-number">4.1</span> The data declaration</h2>
<p>This is the block declaring all of the data variables that must be supplied externally. The Stan variable names mirror those used in the mathematical definitions.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;                    <span class="co">// image dimension</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] R;  <span class="co">// registration image</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; d;                    <span class="co">// separator width</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=N&gt; M1;                   <span class="co">// padded rows</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span> * N + d&gt; M2;           <span class="co">// padded cols</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=M1&gt; r;          <span class="co">// beamstop radius</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N_p;                 <span class="co">// avg photons per pixel</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; Y;      <span class="co">// observed number of photons</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma;               <span class="co">// prior scale</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Stan programs begin execution by reading in the data variables and validating their constraints (e.g., <code>N</code> being positive).</p>
</section>
<section id="transformed-data" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="transformed-data"><span class="header-section-number">4.2</span> Transformed data</h2>
<p>Stan programs allow transforms of data to be defined and saved.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] beamstop = beamstop_gen(M1, M2, r);  <span class="co">// beam stop</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[d, N] Z = rep_matrix(<span class="dv">0</span>, d, N);               <span class="co">// separator</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, N + d] Z_R = append_col(Z, R);            <span class="co">// separator + ref</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This involves three functions, only two of which are built-in, <code>rep_matrix</code> to create the <code>d</code> by <code>N</code> matrix of zero values, and <code>append_col</code> to append the zero padding (<code>Z</code>) and reference image (<code>R</code>, read in as data), together side by side. The function <code>beamstop_gen</code> is user defined and given in its own block at the start of the program along with other functions that are necessary.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span> beamstop_gen(<span class="dt">int</span> M1, <span class="dt">int</span> M2, <span class="dt">int</span> r) {</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">matrix</span>[M1, M2] beamstop = rep_matrix(<span class="dv">0</span>, M1, M2);</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (r == <span class="dv">0</span>) {</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> beamstop;</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    beamstop[<span class="dv">1</span> : r, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">1</span>, r, r);                <span class="co">// upper left</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    beamstop[<span class="dv">1</span> : r, M2 - r + <span class="dv">2</span> : M2] = rep_matrix(<span class="dv">1</span>, r, r - <span class="dv">1</span>);  <span class="co">// upper right</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    beamstop[M1 - r + <span class="dv">2</span> : M1, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">1</span>, r - <span class="dv">1</span>, r);  <span class="co">// lower left</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    beamstop[M1 - r + <span class="dv">2</span> : M1, M2 - r + <span class="dv">2</span> : M2]                   <span class="co">// lower right</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>      = rep_matrix(<span class="dv">1</span>, r - <span class="dv">1</span>, r - <span class="dv">1</span>);</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beamstop;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  ...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function creates the shifted beamstop matrix by initializing a matrix of zeros of the size of the padding (<code>M1</code> by <code>M2</code>, given as arguments), then filling in the corners with 1 values based on the radius of the beamstop (<code>r</code>). There are other functions where the ellipses (<code>...</code>) are shown here, and this block of functions appears first in the full Stan program before the data block. The full Stan program in the index contains full function documentation for this and other user-defined functions appearing in the Stan program.</p>
</section>
<section id="parameter-declaration" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="parameter-declaration"><span class="header-section-number">4.3</span> Parameter declaration</h2>
<p>The parameters are declared but not defined. During execution, parameter values are managed by the optimization or sampling algorithm and will thus be supplied to a Stan program externally.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] X;    <span class="co">// image</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is important that the bounds here, <code>lower=0</code> and <code>upper=1</code> are included on the parameter declaration. These define the constrained domain for <code>X</code>. Stan operates with unconstrained parameters, so the variable <code>X</code> will be implicitly log-odds transformed from <span class="math inline">(0, 1)</span> to <span class="math inline">(-\infty, \infty)</span> (Stan’s intervals are open when going from unconstrained to constrained representations, but can wind up on th boundary due to arithmetic underflow or rounding). Stan implicitly applies the change-of-variables correction for the inverse of the log-odds transform so that a prior may be placed directly on <code>X</code> and propagate correctly to the unconstrained parameers <code>logit(X)</code>.</p>
</section>
<section id="the-model-block" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="the-model-block"><span class="header-section-number">4.4</span> The model block</h2>
<p>The model block defines the log density, adding terms to those already added through the Jacobian determinant of the unconstraining transform.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  X ~ icar(sigma);</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, <span class="dv">2</span> * N + d] X_Z_R = append_col(X, Z_R);</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] V = square(abs(pad_fft2(X_Z_R, M1, M2)));</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] lambda = N_p / mean(V) * V;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (m1 <span class="cf">in</span> <span class="dv">1</span> : M1) {</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (m2 <span class="cf">in</span> <span class="dv">1</span> : M2) {</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (!beamstop[m1, m2]) {</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        Y[m1, m2] ~ poisson(lambda[m1, m2]);</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first line, <code>X ~ icar(sigma)</code> says that <code>X</code> has an ICAR prior. The <code>icar</code> distribution is not built into Stan, so it must be defined by the user. Here’s the definition.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> icar_lpdf(<span class="dt">matrix</span> X, <span class="dt">real</span> sigma) {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> M = rows(X);</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N = cols(X);</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> normal_lpdf(to_vector(X[<span class="dv">2</span>:M, ]) | to_vector(X[<span class="dv">1</span>:M - <span class="dv">1</span>, ]), sigma)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      + normal_lpdf(to_vector(X[ , <span class="dv">2</span>:N]) | to_vector(X[ , <span class="dv">1</span>:N - <span class="dv">1</span>]), sigma);</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Following the math, it’s just a quadratic penalty on differences between row- and column-adjacent elements. Stan allows vector slicing in the same way as MATLAB <span class="citation" data-cites="MATLAB2024">(<a href="#ref-MATLAB2024" role="doc-biblioref">MATLAB Team 2024</a>)</span> and R. The variable <code>sigma</code> controls the amount of regularization applied to adjacent elements; it is supplied as a data variable from the outside, though it could be fit in a hierarchical model.</p>
<p>The second line of the model block defines the matrix <code>X_Z_R</code> to be the result of concatenating the image (parameter <code>X</code>) to the zero separator and reference image (<code>Z_R</code>). The third line defines the matrix <code>V</code> to be the result of performing a two-dimensional FFT on the image, separator and reference padded out to <code>M1</code> rows by zero-padding on the bottom and <code>M2</code> columns by zero-padding on the right. this is defined in the following user-defined function.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">complex_matrix</span> pad_fft2(<span class="dt">complex_matrix</span> Z, <span class="dt">int</span> N, <span class="dt">int</span> M) {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> r = rows(Z);</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c = cols(Z);</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">complex_matrix</span>[N, M] pad = rep_matrix(<span class="dv">0</span>, N, M);</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    pad[<span class="dv">1</span> : r, <span class="dv">1</span> : c] = Z;</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fft2(pad);</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This just pads the matrix with zeros, then applies the built-in two-dimensional FFT function to the padded image, separator, and reference (supplied as the argument <code>Z</code>). The result is a matrix of complex values. The model expression then takes the absolue value of the complex matrix elemenetwise (which produces a real-valued matrix of the smae dimension), the result of which is squared elementwise to produce the matrix <code>V</code>, the entries of which are proportional to the photon flux expected at that position. The next line of the model defines <code>lambda</code> by normalizing <code>V</code> to the expected per-sensor photon count <code>N_p</code>.</p>
<p>The final lines of the model loop over the entries of the padded matrix which are not beamstopped and sample photons (<code>Y</code>) with a Poisson distribution based on the rate (<code>lambda</code>). This defines the likelihood and completes the model specification, which has followed the mathematical definition of the forward model directly.</p>
</section>
<section id="alternative-unconstrained-model" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="alternative-unconstrained-model"><span class="header-section-number">4.5</span> Alternative unconstrained model</h2>
<p>The unconstrained model is almost identical to the constrained-parameter model. It defines an unconstrained representation of parameters, then transforms them in the transformed parameter block as follows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, N] logit_X;  <span class="co">// log-odds transformed image</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed parameters</span> {</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] X = inv_logit(logit_X);  <span class="co">// image</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The parameter for the model is now <code>logit_X</code>, which is the log-odds transformed pixel value. The constrained matrix <code>X</code> is then defined in the transformed parameters block. Here, the constraints in the transformed parameter block, like those in the data block, are just used for error checking—they are validated at the end of the block’s execution and the iteration is rejected with an error message if the constraint fails.</p>
<p>The only other difference is that the ICAR prior is placed directly on the log odds parameters in the model block,</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>  logit_X ~ icar(sigma);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This changes the interpretation of <code>sigma</code> from being on the pixel-value scale <span class="math inline">(0, 1)</span> to the unconstrained scale <span class="math inline">(-\infty, \infty)</span>. The values of <code>logit_X</code> in practice will range between -10 and 10, the extremes of which correspond to nearly pure black and white, respectively.</p>
</section>
</section>
<section id="estimation-and-posterior-inference" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Estimation and Posterior Inference</h1>
<p>Given a Stan program for a model and the corresponding data, fitting the model is straightforward using cmdstanpy <span class="citation" data-cites="standev2024csp">(<a href="#ref-standev2024csp" role="doc-biblioref">Stan Development Team 2024a</a>)</span>.</p>
<section id="compiling-the-models" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="compiling-the-models"><span class="header-section-number">5.1</span> Compiling the models</h2>
<p>The first thing to do is to compile the Stan model. This is done by transpiling from Stan to C++, then compiling the C+ and linking against the rest of Stan’s math library and algorithms. This is all handled by the following CmdStanPy calls, one for the constrained and one for the unconstrained model.</p>
<div id="cd0b6c20" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> csp.CmdStanModel(stan_file<span class="op">=</span><span class="st">'stan/holoCDI.stan'</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>model_unc <span class="op">=</span> csp.CmdStanModel(stan_file<span class="op">=</span><span class="st">'stan/holoCDI-unc.stan'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="constructing-the-data-dictionary" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="constructing-the-data-dictionary"><span class="header-section-number">5.2</span> Constructing the data dictionary</h2>
<p>CmdStanPy takes in data in the form of a Python dictionary. The dictionary needs to define all the variables used in the Stan program and they have to be the right shapes to match the Stan declarations. All of the constants have been defined and the data <code>Y</code> has been simulated. Here, the value for <code>sigma</code> is defined to be 1; other prior scales are evaluated below.</p>
<div id="749c55a2" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N"</span>: N, <span class="st">"R"</span>: R, <span class="st">"d"</span>: N, <span class="st">"M1"</span>: M1, <span class="st">"M2"</span>: M2, <span class="st">"r"</span>: r, <span class="st">"N_p"</span>: N_p,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Y"</span>: Y, <span class="st">"sigma"</span>: sigma</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="optimization-based-point-estimates" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="optimization-based-point-estimates"><span class="header-section-number">5.3</span> Optimization-based point estimates</h2>
<p>In this section, Stan’s optimizer is used to find point estimates as modes of a target density. Stan uses L-BFGS <span class="citation" data-cites="zhu1997">(<a href="#ref-zhu1997" role="doc-biblioref">Zhu et al. 1997</a>)</span>, a limited-memory form of quasi-Newton optimization, which is a widely used black-box optimizer that uses finite-differences of the past few gradients to approximate a low-rank plus diagonal preconditioner dynamically during optimization. This reduces linear algebra from the <span class="math inline">\mathcal{O}(N^3)</span> required for Newton’s method to <span class="math inline">\mathcal{O}(J^2 \cdot N),</span> where <span class="math inline">J</span> is the rank of the preconditioner before adding the diagonal to make it positive definite.</p>
<section id="penalized-maximum-likelihood-estimation" class="level3" data-number="5.3.1">
<h3 data-number="5.3.1" class="anchored" data-anchor-id="penalized-maximum-likelihood-estimation"><span class="header-section-number">5.3.1</span> Penalized maximum likelihood estimation</h3>
<p>Interpreting the ICAR prior as a quadratic penalty, a penalized maximum likelihood estimate (MLE) <span class="math inline">x^*</span> is defined by <span class="math display">\begin{equation}
x^* = \textrm{arg max}_x \log p(y; \, x) + \log \textrm{icar}(x),
\end{equation}</span> but with no Jacobian adjustment for any change-of-variables used to constrain <span class="math inline">x</span> because <span class="math inline">x</span> is no longer considered to be a random variable (hence the semicolon in the notation).</p>
<p>This estimate can be computed through optimization in Stan and extracted into a Python variable.</p>
<div id="b89101b5" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>fit_mle <span class="op">=</span> model.optimize(data <span class="op">=</span> data, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">False</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>X_hat_mle <span class="op">=</span> fit_mle.stan_variable(<span class="st">'X'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A random seed is hardcoded for reproducibility and initialiation is specified to be <span class="math inline">\textrm{uniform}(-0.5, 0.5)</span> on the unconstrained scale. The Jacobian adjustment for the constrained parameter is turned off here for computing the MLE.</p>
</section>
<section id="maximum-a-posteriori-estimation" class="level3" data-number="5.3.2">
<h3 data-number="5.3.2" class="anchored" data-anchor-id="maximum-a-posteriori-estimation"><span class="header-section-number">5.3.2</span> Maximum a posteriori estimation</h3>
<p>An alternative point estimation strategy can be derived by taking the point in the posterior with maximum posterior log density. Here, the Jacobian adjustment for the constraining transform to x is included as part of the definition of <span class="math inline">p(x \mid y)</span>.</p>
<p><span class="math display">\begin{equation}
x^{**} = \textrm{arg max}_x \log p(x \mid y).
\end{equation}</span></p>
<p>The maximum a posteriori (MAP) estimate can be calculated with optimization in Stan by turning on the Jacobian adjustment for constrained parameters.</p>
<div id="0022d6b9" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>fit_map <span class="op">=</span> model.optimize(data <span class="op">=</span> data, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">True</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>X_hat_map <span class="op">=</span> fit_map.stan_variable(<span class="st">'X'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="mle-and-map-for-unconstrained-model" class="level3" data-number="5.3.3">
<h3 data-number="5.3.3" class="anchored" data-anchor-id="mle-and-map-for-unconstrained-model"><span class="header-section-number">5.3.3</span> MLE and MAP for unconstrained model</h3>
<p>The third estimation strategy involves the direct unconstrained parameterization with an ICAR prior on the unconstrained parameters. Because there are no constraining transforms, the penalized MLE and MAP estimates coincide. These can be computed in Stan as follows.</p>
<div id="03f0bb9a" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>sigma_unc <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>data_unc <span class="op">=</span> {</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N"</span>: N, <span class="st">"R"</span>: R, <span class="st">"d"</span>: N, <span class="st">"M1"</span>: M1, <span class="st">"M2"</span>: M2, <span class="st">"r"</span>: r, <span class="st">"N_p"</span>: N_p,</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Y"</span>: Y, <span class="st">"sigma"</span>: sigma_unc</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>fit_mle_unc <span class="op">=</span> model_unc.optimize(data <span class="op">=</span> data_unc, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">False</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>X_hat_mle_unc <span class="op">=</span> fit_mle_unc.stan_variable(<span class="st">'X'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="visualizing-the-optimization-based-fits" class="level3" data-number="5.3.4">
<h3 data-number="5.3.4" class="anchored" data-anchor-id="visualizing-the-optimization-based-fits"><span class="header-section-number">5.3.4</span> Visualizing the optimization-based fits</h3>
<p><a href="#fig-pointfits" class="quarto-xref">Figure&nbsp;8</a> shows the fits for the MLE, MAP, and unconstrained MLE/MAP estimates as well as the original image from which data is simulated.</p>
<div id="cell-fig-pointfits" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_plot(fig, m, n, k, title, x):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(m, n, k, title<span class="op">=</span>title)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    ax.imshow(x, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks([])</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks([])</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="st">"(a) source"</span>, X_src)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="st">"(b) MLE"</span>, X_hat_mle)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="st">"(c) MAP"</span>, X_hat_map)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="st">"(d) MLE/MAP [unc]"</span>, X_hat_mle_unc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-pointfits" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="t" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pointfits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-pointfits-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="t">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pointfits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Original image and optimization-based reconstructions. (a) original source image, (b) penalized maximum likelihood estimate, (c) maximum a posteriori estimate, (d) penalized maximum likelihood (equivalently maximum a posteriori) estimate for unconstrained model.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="effect-of-prior-scale" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="effect-of-prior-scale"><span class="header-section-number">5.4</span> Effect of prior scale</h2>
<p>There is a free tuning parameter <span class="math inline">\sigma,</span> which is the prior scale. This is input as data to the Stan program and used in the ICAR prior to smooth (i.e., regularize) the values of adjacent pixels toward each other. The earlier example used <span class="math inline">\sigma = 1,</span> which does very little smoothing given that the range of values is 0 to 1. A range of values for <span class="math inline">\sigma</span> can be evaluated in a loop.</p>
<div id="8c2a8d6d" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>sigmas <span class="op">=</span> [<span class="dv">1</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">64</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">16</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">16</span>]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>J <span class="op">=</span> <span class="bu">len</span>(sigmas)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>X_fits <span class="op">=</span> np.ones(shape<span class="op">=</span>(J, <span class="dv">256</span>, <span class="dv">256</span>))</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>data_varying_sigma <span class="op">=</span> data.copy()</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, sigma <span class="kw">in</span> <span class="bu">enumerate</span>(sigmas):</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    data_varying_sigma[<span class="st">'sigma'</span>] <span class="op">=</span> sigma</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> model.optimize(data <span class="op">=</span> data_varying_sigma, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">True</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    X_fits[j, :, :] <span class="op">=</span> fit.stan_variable(<span class="st">'X'</span>).copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The resulting estimates are displayed in <a href="#fig-sigmas" class="quarto-xref">Figure&nbsp;9</a>.</p>
<div id="cell-fig-sigmas" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">2</span>, (J <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>, <span class="dv">1</span>, <span class="st">"source"</span>, X_src)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, sigma <span class="kw">in</span> <span class="bu">enumerate</span>(sigmas):</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    add_plot(fig, <span class="dv">2</span>, (J <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>, j <span class="op">+</span> <span class="dv">2</span>, <span class="ss">f"sigma: </span><span class="sc">{</span>sigma<span class="sc">:5.3f}</span><span class="ss">"</span>, X_fits[j])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-sigmas" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="top" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-sigmas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="HoloCDI_files/figure-html/fig-sigmas-output-1.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" data-fig-pos="top">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-sigmas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Effect of different sigma values on smoothing.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="bayesian-estimates-and-samples" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="bayesian-estimates-and-samples"><span class="header-section-number">5.5</span> Bayesian estimates and samples</h2>
<p>We consider two Bayesian methods, both of which produce draws and allow for plug-in Monte Carlo estimation of posterior predictive quantitites. The first is variational inference, which provide approximate posterior draws, and the second is Markov-chain Monte Carlo, which is much more expensive, but produces unbiased posterior draws.</p>
<section id="variational-inference" class="level3" data-number="5.5.1">
<h3 data-number="5.5.1" class="anchored" data-anchor-id="variational-inference"><span class="header-section-number">5.5.1</span> Variational inference</h3>
<p>Variational inference fits an approximate distribution <span class="math inline">q(x \mid \phi)</span> to the target posterior density <span class="math inline">p(x \mid y)</span> by choosing the approximating parameters <span class="math inline">\phi</span> that render it closest in terms of Kullback-Leibler divergence, <span class="math display">\begin{equation}
\phi^* = \textrm{arg max}_\phi \ \textrm{KL}[q(x \mid \phi) || p(x \mid y)].
\end{equation}</span> In this case study, the Pathfinder approach is used <span class="citation" data-cites="zhang2022">(<a href="#ref-zhang2022" role="doc-biblioref">Zhang et al. 2022</a>)</span>. Pathfinder runs quasi-Newton optimization on the target density <span class="math inline">p(x \mid y)</span> from random initializations and then uses points along the optimization trajectory as the location of second-order Taylor approximations to the target density with the low-rank plus diagonal covariance estimated by the L-BFGS optimizer. The result is a series of multivariate normal approximations. Each of these is evaluated for KL-divergence using Monte Carlo methods (which are stable for the KL divergence in a way they are not stable for the gradients). This is done several times and then the normal approximations are sampled using importance resampling. This gives us unconstrained draws, which are then constrained to give the final set of draws for the method.</p>
<p>Pathfinder is straightforward to run.</p>
<div id="d53c9a8c" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit_pf = model.pathfinder(data, inits=1, max_lbfgs_iters=10,</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     psis_resample=True, num_elbo_draws=10,</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">#     num_paths=2, draws=100, num_single_draws=100,</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">#     show_console=False, seed=5678)</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co"># draws_pf_X = fit_pf.stan_variables()['X']</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="co"># X_hat_pf = np.mean(draws_pf_X, axis=0)</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co"># X_draw_pf = draws_pf_X[10, :]  # 10 is just arbitrary draw</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="markov-chain-monte-carlo" class="level3" data-number="5.5.2">
<h3 data-number="5.5.2" class="anchored" data-anchor-id="markov-chain-monte-carlo"><span class="header-section-number">5.5.2</span> Markov-chain Monte Carlo</h3>
<p>Markov-chain Monte Carlo methods run a Markov chain, which in the limit has the target density as its stationary distribution. This allows draws from the chain to be used for plug-in Monte Carlo estimates.</p>
<p>Sampling is run in the same way as Pathinder, with draws being extracted and averaged to create the estimate.</p>
<div id="0ca588ee" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># inits_from_pf = fit_pf.create_inits(2, seed = 5678)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co"># fit_sample = model.sample(data, inits=inits_from_pf, chains=2, parallel_chains=2,</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">#                           iter_warmup=20, iter_sampling=20,</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">#                           show_console=False, show_progress=False,</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">#                           seed = 5678, max_treedepth=5)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co"># draws_mcmc_X = fit_sample.stan_variable('X')</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co"># X_hat_mcmc = np.mean(draws_mcmc_X, axis=0)</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="co"># X_draw_mcmc = draws_mcmc_X[10, :]  # 10 is an arbitrary draw</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="plotting-mcmc-derived-fits" class="level3" data-number="5.5.3">
<h3 data-number="5.5.3" class="anchored" data-anchor-id="plotting-mcmc-derived-fits"><span class="header-section-number">5.5.3</span> Plotting MCMC-derived fits</h3>
<div id="fig-bayesfits" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="22">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bayesfits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># figbayes = plt.figure()</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 1, "(a) source", X_src)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 2, "(b) VI [draw]", X_draw_pf)</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 3, "(c) VI [mean]", X_hat_pf)</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 4, "(d) MCMC [draw]", X_draw_mcmc)</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 5, "(e) MCMC [mean]", X_hat_mcmc)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-bayesfits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10
</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-barmherzig2022" class="csl-entry" role="listitem">
Barmherzig, David A, and Ju Sun. 2022. <span>“Towards Practical Holographic Coherent Diffraction Imaging via Maximum Likelihood Estimation.”</span> <em>Optics Express</em> 30 (5): 6886–906. <a href="https://doi.org/10.1364/OE.445015">https://doi.org/10.1364/OE.445015</a>.
</div>
<div id="ref-barmherzig2019" class="csl-entry" role="listitem">
Barmherzig, David A, Ju Sun, Po-Nan Li, T J Lane, and Emmanuel J Candès. 2019. <span>“Holographic Phase Retrieval and Reference Design.”</span> <em>Inverse Problems</em> 35 (9): 094001. <a href="https://doi.org/10.1088/1361-6420/ab23d1">https://doi.org/10.1088/1361-6420/ab23d1</a>.
</div>
<div id="ref-barnett2020" class="csl-entry" role="listitem">
Barnett, Alexander H, Charles L Epstein, Leslie F Greengard, and Jeremy F Magland. 2020. <span>“Geometry of the Phase Retrieval Problem.”</span> <em>Inverse Problems</em> 36 (9): 094003. <a href="https://doi.org/10.1088/1361-6420/aba5ed">https://doi.org/10.1088/1361-6420/aba5ed</a>.
</div>
<div id="ref-besag1991" class="csl-entry" role="listitem">
Besag, Julian, Jeremy York, and Annie Mollié. 1991. <span>“Bayesian Image Restoration, with Two Applications in Spatial Statistics.”</span> <em>Annals of the Institute of Statistical Mathematics</em> 43: 1–20.
</div>
<div id="ref-carpenter2017" class="csl-entry" role="listitem">
Carpenter, Bob, Andrew Gelman, Matthew D Hoffman, Daniel Lee, Ben Goodrich, Michael Betancourt, Marcus A Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell. 2017. <span>“Stan: A Probabilistic Programming Language.”</span> <em>Journal of Statistical Software</em> 76.
</div>
<div id="ref-carpenter2015" class="csl-entry" role="listitem">
Carpenter, Bob, Matthew D Hoffman, Marcus Brubaker, Daniel Lee, Peter Li, and Michael Betancourt. 2015. <span>“The Stan Math Library: Reverse-Mode Automatic Differentiation in <span>C++</span>.”</span> <em>arXiv</em> 1509 (07164).
</div>
<div id="ref-fei2023" class="csl-entry" role="listitem">
Fei, Ben, Zhaoyang Lyu, Liang Pan, Junzhe Zhang, Weidong Yang, Tianyue Luo, Bo Zhang, and Bo Dai. 2023. <span>“Generative Diffusion Prior for Unified Image Restoration and Enhancement.”</span> In <em>Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition</em>, 9935–46.
</div>
<div id="ref-fenimore1978" class="csl-entry" role="listitem">
Fenimore, E. E., and T. M. Cannon. 1978. <span>“Coded Aperture Imaging with Uniformly Redundant Arrays.”</span> <em>Applied Optics</em> 17 (3): 337–47. <a href="https://doi.org/10.1364/AO.17.000337">https://doi.org/10.1364/AO.17.000337</a>.
</div>
<div id="ref-graikos2022" class="csl-entry" role="listitem">
Graikos, Alexandros, Nikolay Malkin, Nebojsa Jojic, and Dimitris Samaras. 2022. <span>“Diffusion Models as Plug-and-Play Priors.”</span> <em>Advances in Neural Information Processing Systems</em> 35: 14715–28.
</div>
<div id="ref-hoffman2014" class="csl-entry" role="listitem">
Hoffman, Matthew D, Andrew Gelman, et al. 2014. <span>“The No-<span>U</span>-Turn Sampler: Adaptively Setting Path Lengths in <span>H</span>amiltonian <span>M</span>onte <span>C</span>arlo.”</span> <em>Journal of Machine Learning Research</em> 15 (1): 1593–623.
</div>
<div id="ref-kadkhodaie2021" class="csl-entry" role="listitem">
Kadkhodaie, Zahra, and Eero Simoncelli. 2021. <span>“Stochastic Solutions for Linear Inverse Problems Using the Prior Implicit in a Denoiser.”</span> <em>Advances in Neural Information Processing Systems</em> 34: 13242–54.
</div>
<div id="ref-lunn2013" class="csl-entry" role="listitem">
Lunn, David, Christopher Jackson, Nicky Best, Andrew Thomas, and David Spiegelhalter. 2013. <em>The <span>BUGS</span> Book: A Practical Introduction to Bayesian Analysis, Chapman Hall, London</em>. CRC.
</div>
<div id="ref-MATLAB2024" class="csl-entry" role="listitem">
MATLAB Team. 2024. <em>MATLAB Reference Manual</em> (version R2023b). Natick, Massachusetts: The MathWorks Inc.
</div>
<div id="ref-rteam2000" class="csl-entry" role="listitem">
R Core Team. 2000. <span>“R Language Definition.”</span> <em>R Journal</em> 3 (1).
</div>
<div id="ref-standev2024csp" class="csl-entry" role="listitem">
Stan Development Team. 2024a. <span>“<span>CmdStanPy</span>: A <span>P</span>ython Interface to <span>S</span>tan.”</span> <a href="https://mc-stan.org/cmdstanpy/">https://mc-stan.org/cmdstanpy/</a>.
</div>
<div id="ref-standev2024ref" class="csl-entry" role="listitem">
———. 2024b. <span>“Stan Reference Manual.”</span> <a href="https://mc-stan.org/docs/reference-manual/">https://mc-stan.org/docs/reference-manual/</a>.
</div>
<div id="ref-standev2024users" class="csl-entry" role="listitem">
———. 2024c. <span>“Stan User’s Guide.”</span> <a href="https://mc-stan.org/docs/stan-users-guide/">https://mc-stan.org/docs/stan-users-guide/</a>.
</div>
<div id="ref-vanrossum2010" class="csl-entry" role="listitem">
van Rossum, Guido, and Fred L Drake. 2010. <em>The <span>P</span>ython Language Reference</em>. Vol. 561. Scotts Valley, California: CreateSpace Independent Publishers. <a href="https://docs.python.org/3/reference/index.html">https://docs.python.org/3/reference/index.html</a>.
</div>
<div id="ref-zhang2022" class="csl-entry" role="listitem">
Zhang, Lu, Bob Carpenter, Andrew Gelman, and Aki Vehtari. 2022. <span>“Pathfinder: Parallel Quasi-<span>N</span>ewton Variational Inference.”</span> <em>The Journal of Machine Learning Research</em> 23 (1): 13802–50.
</div>
<div id="ref-zhu1997" class="csl-entry" role="listitem">
Zhu, Ciyou, Richard H Byrd, Peihuang Lu, and Jorge Nocedal. 1997. <span>“Algorithm 778: <span>L-BFGS-B</span>: <span>F</span>ortran Subroutines for Large-Scale Bound-Constrained Optimization.”</span> <em>ACM Transactions on Mathematical Software (TOMS)</em> 23 (4): 550–60.
</div>
</div>
</section>
<section id="appendicies" class="level1 unnumbered">
<h1 class="unnumbered">Appendicies</h1>
</section>


<div id="quarto-appendix" class="default"><section id="a.-stan-programs" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">A. Stan Programs</h2><div class="quarto-appendix-contents">



</div></section><section id="a.1-constrained-parameter-version" class="level2 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">A.1 Constrained parameter version</h2><div class="quarto-appendix-contents">

<div class="sourceCode" id="cb36"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return a beam stop of dimension M1 x M2, with 1 values blocking</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">   * the lowest frequency portions of an FFT and 0 values elsewhere.</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">   * The result is an M1 x M2 matrix of 0 values with blocks in the</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">   * corners set to 1.  The block sizes are upper left (r x r), upper</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">   * right (r x r-1), lower left (r-1 x r), and lower right (r-1 x</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">   * r-1).</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">   *</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M1 number of rows</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M2 number of cols</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> r block dimension</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> M1 x M2 matrix with 1 for stopped and 0 for passed values.</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span> beamstop_gen(<span class="dt">int</span> M1, <span class="dt">int</span> M2, <span class="dt">int</span> r) {</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">matrix</span>[M1, M2] beamstop = rep_matrix(<span class="dv">0</span>, M1, M2);</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (r == <span class="dv">0</span>) {</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> beamstop;</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    beamstop[<span class="dv">1</span> : r, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">1</span>, r, r);                <span class="co">// upper left</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    beamstop[<span class="dv">1</span> : r, M2 - r + <span class="dv">2</span> : M2] = rep_matrix(<span class="dv">1</span>, r, r - <span class="dv">1</span>);  <span class="co">// upper right</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    beamstop[M1 - r + <span class="dv">2</span> : M1, <span class="dv">1</span> : r] = rep_matrix(<span class="dv">1</span>, r - <span class="dv">1</span>, r);  <span class="co">// lower left</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    beamstop[M1 - r + <span class="dv">2</span> : M1, M2 - r + <span class="dv">2</span> : M2]                   <span class="co">// lower right</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>      = rep_matrix(<span class="dv">1</span>, r - <span class="dv">1</span>, r - <span class="dv">1</span>);</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beamstop;</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return the matrix corresponding to the fast Fourier transform of</span></span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a><span class="co">   * Z after it is padded with zeros (to the right and below) to shape</span></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a><span class="co">   * N x M.  When N x M is larger than the dimensions of Z, the result</span></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a><span class="co">   * is an oversampled two-dimensional discrete Fourier transform.</span></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a><span class="co">   *</span></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> Z matrix of values</span></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> N number of rows desired (must be &gt;= rows(Z))</span></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M number of columns desired (must be &gt;= cols(Z))</span></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> the FFT of Z padded with zeros</span></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">complex_matrix</span> pad_fft2(<span class="dt">complex_matrix</span> Z, <span class="dt">int</span> N, <span class="dt">int</span> M) {</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> r = rows(Z);</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c = cols(Z);</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">complex_matrix</span>[N, M] pad = rep_matrix(<span class="dv">0</span>, N, M);</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>    pad[<span class="dv">1</span> : r, <span class="dv">1</span> : c] = Z;</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fft2(pad);</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return the intrinsic conditional autoregressive prior density</span></span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a><span class="co">   * for the specified image matrix X.  this is</span></span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a><span class="co">   *</span></span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> X image matrix with values in (0, 1)</span></span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> sigma scale of ICAR prior</span></span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> ICAR log density for the specified matrix and scale</span></span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> icar_lpdf(<span class="dt">matrix</span> X, <span class="dt">real</span> sigma) {</span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> M = rows(X);</span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N = cols(X);</span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> normal_lupdf(to_vector(X[<span class="dv">2</span>:M, ]) | to_vector(X[<span class="dv">1</span>:M - <span class="dv">1</span>, ]), sigma)</span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a>      + normal_lupdf(to_vector(X[ , <span class="dv">2</span>:N]) | to_vector(X[ , <span class="dv">1</span>:N - <span class="dv">1</span>]), sigma);</span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb36-61"><a href="#cb36-61" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-62"><a href="#cb36-62" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb36-63"><a href="#cb36-63" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;                    <span class="co">// image dimension</span></span>
<span id="cb36-64"><a href="#cb36-64" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] R;  <span class="co">// registration image</span></span>
<span id="cb36-65"><a href="#cb36-65" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; d;                    <span class="co">// separator width</span></span>
<span id="cb36-66"><a href="#cb36-66" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=N&gt; M1;                   <span class="co">// padded rows</span></span>
<span id="cb36-67"><a href="#cb36-67" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span> * N + d&gt; M2;           <span class="co">// padded cols</span></span>
<span id="cb36-68"><a href="#cb36-68" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=M1&gt; r;          <span class="co">// beamstop radius</span></span>
<span id="cb36-69"><a href="#cb36-69" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N_p;                 <span class="co">// avg photons per pixel</span></span>
<span id="cb36-70"><a href="#cb36-70" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; Y;      <span class="co">// observed number of photons</span></span>
<span id="cb36-71"><a href="#cb36-71" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma;               <span class="co">// prior scale</span></span>
<span id="cb36-72"><a href="#cb36-72" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-73"><a href="#cb36-73" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb36-74"><a href="#cb36-74" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] beamstop = beamstop_gen(M1, M2, r);  <span class="co">// beam stop</span></span>
<span id="cb36-75"><a href="#cb36-75" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[d, N] Z = rep_matrix(<span class="dv">0</span>, d, N);               <span class="co">// separator</span></span>
<span id="cb36-76"><a href="#cb36-76" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, N + d] Z_R = append_col(Z, R);            <span class="co">// separator + ref</span></span>
<span id="cb36-77"><a href="#cb36-77" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-78"><a href="#cb36-78" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb36-79"><a href="#cb36-79" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] X;    <span class="co">// image</span></span>
<span id="cb36-80"><a href="#cb36-80" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-81"><a href="#cb36-81" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb36-82"><a href="#cb36-82" aria-hidden="true" tabindex="-1"></a>  X ~ icar(sigma);</span>
<span id="cb36-83"><a href="#cb36-83" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, <span class="dv">2</span> * N + d] X_Z_R = append_col(X, Z_R);</span>
<span id="cb36-84"><a href="#cb36-84" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] V = square(abs(pad_fft2(X_Z_R, M1, M2)));</span>
<span id="cb36-85"><a href="#cb36-85" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] lambda = N_p / mean(V) * V;</span>
<span id="cb36-86"><a href="#cb36-86" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (m1 <span class="cf">in</span> <span class="dv">1</span> : M1) {</span>
<span id="cb36-87"><a href="#cb36-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (m2 <span class="cf">in</span> <span class="dv">1</span> : M2) {</span>
<span id="cb36-88"><a href="#cb36-88" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (beamstop[m1, m2] != <span class="dv">1</span>) {</span>
<span id="cb36-89"><a href="#cb36-89" aria-hidden="true" tabindex="-1"></a>        Y[m1, m2] ~ poisson(lambda[m1, m2]);</span>
<span id="cb36-90"><a href="#cb36-90" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb36-91"><a href="#cb36-91" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb36-92"><a href="#cb36-92" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb36-93"><a href="#cb36-93" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></section><section id="a.2-unconstrained-parameter-version" class="level2 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">A.2 Unconstrained parameter version</h2><div class="quarto-appendix-contents">

<div class="sourceCode" id="cb37"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return a beam stop of dimension M1 x M2, with 1 values blocking</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">   * the lowest frequency portions of an FFT and 0 values elsewhere.</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co">   * The result is an M1 x M2 matrix of 0 values with blocks in the</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">   * corners set to 1.  The block sizes are upper left (r x r), upper</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co">   * right (r x r-1), lower left (r-1 x r), and lower right (r-1 x</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co">   * r-1).</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M1 number of rows</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M2 number of cols</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> r block dimension</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> M1 x M2 matrix with 1 for stopped and 0 for passed values.</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[ , ] <span class="dt">int</span> beamstop_gen(<span class="dt">int</span> M1, <span class="dt">int</span> M2, <span class="dt">int</span> r) {</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">array</span>[M1, M2] <span class="dt">int</span> B_cal = rep_array(<span class="dv">0</span>, M1, M2);</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (r == <span class="dv">0</span>) {</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> B_cal;</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    B_cal[<span class="dv">1</span> : r, <span class="dv">1</span> : r] = rep_array(<span class="dv">1</span>, r, r);                <span class="co">// upper left</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    B_cal[<span class="dv">1</span> : r, M2 - r + <span class="dv">2</span> : M2] = rep_array(<span class="dv">1</span>, r, r - <span class="dv">1</span>);  <span class="co">// upper right</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>    B_cal[M1 - r + <span class="dv">2</span> : M1, <span class="dv">1</span> : r] = rep_array(<span class="dv">1</span>, r - <span class="dv">1</span>, r);  <span class="co">// lower left</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    B_cal[M1 - r + <span class="dv">2</span> : M1, M2 - r + <span class="dv">2</span> : M2]                   <span class="co">// lower right</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>      = rep_array(<span class="dv">1</span>, r - <span class="dv">1</span>, r - <span class="dv">1</span>);</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_cal;</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return the matrix corresponding to the fast Fourier transform of</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a><span class="co">   * Z after it is padded with zeros (to the right and below) to shape</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a><span class="co">   * N x M.  When N x M is larger than the dimensions of Z, the result</span></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a><span class="co">   * is an oversampled two-dimensional discrete Fourier transform.</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a><span class="co">   *</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> Z matrix of values</span></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> N number of rows desired (must be &gt;= rows(Z))</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> M number of columns desired (must be &gt;= cols(Z))</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> the FFT of Z padded with zeros</span></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">complex_matrix</span> pad_fft2(<span class="dt">complex_matrix</span> Z, <span class="dt">int</span> N, <span class="dt">int</span> M) {</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> r = rows(Z);</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c = cols(Z);</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">complex_matrix</span>[N, M] pad = rep_matrix(<span class="dv">0</span>, N, M);</span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>    pad[<span class="dv">1</span> : r, <span class="dv">1</span> : c] = Z;</span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fft2(pad);</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">/**</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="co">   * Return the intrinsic conditional autoregressive prior density</span></span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a><span class="co">   * for the specified image matrix X.  this is </span></span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a><span class="co">   *</span></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> X image matrix with values in (0, 1)</span></span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> sigma scale of ICAR prior</span></span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a><span class="co">   * </span><span class="an">@return</span><span class="co"> ICAR log density for the specified matrix and scale</span></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a><span class="co">   */</span></span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> icar_lpdf(<span class="dt">matrix</span> X, <span class="dt">real</span> sigma) {</span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N = rows(X);</span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> M = cols(X);</span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> normal_lpdf(to_vector(X[<span class="dv">2</span>:N, ]) | to_vector(X[<span class="dv">1</span>:N - <span class="dv">1</span>, ]), sigma)</span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>      + normal_lpdf(to_vector(X[ , <span class="dv">2</span>:M]) | to_vector(X[ , <span class="dv">1</span>:M - <span class="dv">1</span>]), sigma);</span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;                    <span class="co">// image dimension</span></span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] R;  <span class="co">// registration image</span></span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=N&gt; d;           <span class="co">// separator</span></span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=N&gt; M1;                   <span class="co">// padded rows</span></span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span> * N + d&gt; M2;           <span class="co">// padded cols</span></span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=M1&gt; r;          <span class="co">// beamstop radius</span></span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N_p;                 <span class="co">// avg photons per pixel</span></span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; Y;      <span class="co">// observed number of photons</span></span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma;               <span class="co">// prior scale</span></span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[M1, M2] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; beamstop = beamstop_gen(M1, M2, r);</span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[d, N] Z = rep_matrix(<span class="dv">0</span>, d, N);      <span class="co">// seperator</span></span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, N + d] Z_R = append_col(Z, R);   <span class="co">// separator + ref</span></span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, N] logit_X;  <span class="co">// log-odds transformed image</span></span>
<span id="cb37-80"><a href="#cb37-80" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-81"><a href="#cb37-81" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed parameters</span> {</span>
<span id="cb37-82"><a href="#cb37-82" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[N, N] X = inv_logit(logit_X);  <span class="co">// image</span></span>
<span id="cb37-83"><a href="#cb37-83" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-84"><a href="#cb37-84" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb37-85"><a href="#cb37-85" aria-hidden="true" tabindex="-1"></a>  logit_X ~ icar(sigma);</span>
<span id="cb37-86"><a href="#cb37-86" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, <span class="dv">2</span> * N + d] X_Z_R = append_col(X, Z_R);</span>
<span id="cb37-87"><a href="#cb37-87" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] V = square(abs(pad_fft2(X_Z_R, M1, M2)));</span>
<span id="cb37-88"><a href="#cb37-88" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[M1, M2] lambda = N_p / mean(V) * V; </span>
<span id="cb37-89"><a href="#cb37-89" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (m1 <span class="cf">in</span> <span class="dv">1</span> : M1) {</span>
<span id="cb37-90"><a href="#cb37-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (m2 <span class="cf">in</span> <span class="dv">1</span> : M2) {</span>
<span id="cb37-91"><a href="#cb37-91" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (!beamstop[m1, m2]) {</span>
<span id="cb37-92"><a href="#cb37-92" aria-hidden="true" tabindex="-1"></a>        Y[m1, m2] ~ poisson(lambda[m1, m2]);</span>
<span id="cb37-93"><a href="#cb37-93" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb37-94"><a href="#cb37-94" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb37-95"><a href="#cb37-95" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-96"><a href="#cb37-96" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- -->

</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{ward2024,
  author = {Ward, Brian and Carpenter, Bob and Barmherzig, David},
  publisher = {Société Française de Statistique},
  title = {Estimation and {Sampling} for {Holographic} {Coherent}
    {Diffraction} {Imaging}},
  journal = {Computo},
  date = {2024-08-14},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {This case study provides a forward statistical model for
    holographic coherent diffraction imaging (Holo CDI) that generates a
    random photon flux from an image and explores several ways of
    solving the inverse problem (i.e., recovering the image from the
    measured flux). Maximum a posteriori estimates (MAP) and penalized
    maximum likelihood estimates (MLE) are provided by limited memory
    quasi-Newton optimization (L-BFGS). Variational Bayes (VB) is
    implemented with Pathfinder. Markov chain Monte Carlo (MCMC) is
    implemented with the no-U-turn sampler (NUTS). Evaluations include
    log density, root mean square error (RMSE), and the image-specific
    measures structural similarity (SSIM) and and peak signal-to-noise
    ratio (PSNR).}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-ward2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Ward, Brian, Bob Carpenter, and David Barmherzig. 2024.
<span>“Estimation and Sampling for Holographic Coherent Diffraction
Imaging.”</span> <em>Computo</em>, August. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb38" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Estimation and Sampling for Holographic Coherent Diffraction Imaging"</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "Low-photon phase retrieval with MLE, MAP, VB, and MCMC"</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Brian Ward</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: bward@flatironinstitute.org</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://brianward.dev/</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-9841-3342</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Flatiron Institute</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Center for Computational Mathematics</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Bob Carpenter</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co">    email: bcarpenter@flatironinstitute.org</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://bob-carpenter.github.io/</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-2433-9688</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Flatiron Institute</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Center for Computational Mathematics</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: David Barmherzig</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a><span class="co">    email: dbarmherzig@flatironinstitute.org</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://davidbar.org/</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0003-2466-981X</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Flatiron Institute</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Center for Computational Mathematics</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.simonsfoundation.org/flatiron/center-for-computational-mathematics/</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a><span class="co">#  This case study surveys several inference and evaluation schemes for holographic coherent diffraction imaging.</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a><span class="co">  This case study provides a forward statistical model for holographic coherent diffraction imaging (Holo CDI) that generates a random photon flux from an image and explores several ways of solving the inverse problem (i.e., recovering the image from the measured flux). Maximum a posteriori estimates (MAP) and penalized maximum likelihood estimates (MLE) are provided by limited memory quasi-Newton optimization (L-BFGS).  Variational Bayes (VB) is implemented with Pathfinder.  Markov chain Monte Carlo (MCMC) is implemented with the no-U-turn sampler (NUTS).  Evaluations include log density, root mean square error (RMSE), and the image-specific measures structural similarity (SSIM) and and peak signal-to-noise ratio (PSNR).</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [Stan, coherent-diffraction-imaging, statistics, bayesian, phase-retrieval, inverse-problem &lt;br /&gt; &lt;br /&gt; ]</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> WardBrian</span></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "holoml-in-stan-computo"</span></span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a><span class="an">monobackgroundcolor:</span><span class="co"> white</span></span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a><span class="co">#  computo-pdf: default</span></span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>Coherent diffraction imaging (CDI) is a technique for imaging nanoscale biomolecules such as macroviruses and proteins.  CDI involves exposing the object being imaged to a coherent beam of X-rays and measuring the diffracted photon flux at a sensor placed behind the object being imaged.  The diffraction pattern theoretically follows a Fourier transform, but only the squared magnitude is observed, which induces a phase-retrieval problem where the real and imaginary components of the complex variables must be inferred so that the process may be inverted to form an image.  Solving the inverse problem for CDI is highly challenging and typically lacks a unique solution <span class="co">[</span><span class="ot">@barnett2020</span><span class="co">]</span>.</span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>Holographic coherent diffraction imaging (HCDI) is a variant of CDI in which the specimen is placed some distance away from a known reference object, and the data observed is the pattern of  diffraction around both the specimen and the reference. The addition of a reference object reduces the inverse problem to a linear deconvolution problem which has a unique, closed-form solution in the idealized setting <span class="co">[</span><span class="ot">@barmherzig2019</span><span class="co">]</span>.</span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>In this note, we follow @barmherzig2022 in defining a forward statistical model that, given the image being reconstructed, defines the expected photon flux at the sensors in terms of the Fourier transform of the image and Poisson sampling of incident photons.  Starting from the model of @barmherzig2022, we add an intrinsic conditional autoregressive (ICAR) prior on the image which can be used to control smoothing of adjacent pixels <span class="co">[</span><span class="ot">@besag1991</span><span class="co">]</span>.  We then log-odds (logit) transform the parameters of the model, which represent pixel intensity between 0 and 1, into unconstrained variables so the model has support on all of $\mathbb{R}^{M \times N}$ for an $M \times N$ pixel image.</span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a>The forward model of holographic CDI defines a sampling distribution for the observed photon flux.  When combined with a prior, the forward model induces an inverse problem whereby we measure photon flux on a grid of sensors and infer the image that caused it.  We will explore the following standard algorithms for exact and approximate solution of the inverse problem.</span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Penalized maxmum likelihood (MLE):  Solve with optimization, do not adjust for unconstraining transform.</span>
<span id="cb38-68"><a href="#cb38-68" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Maximum a posteriori (MAP): Solve with optimization, adjusting for the unconstraining transform.</span>
<span id="cb38-69"><a href="#cb38-69" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Variational Bayes (VB): Solve by minimizing Kullback-Leibler divergence from an approximate posterior to the true posterior and importance resampling.</span>
<span id="cb38-70"><a href="#cb38-70" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Markov chain Monte Carlo (MCMC): Solve by sampling from the posterior and averaging.</span>
<span id="cb38-71"><a href="#cb38-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-72"><a href="#cb38-72" aria-hidden="true" tabindex="-1"></a>Computationally, we will code the models using Stan <span class="co">[</span><span class="ot">@carpenter2017</span><span class="co">]</span>, a probabilistic programming language for expressing differentiable log densities.  All that is needed to solve the inverse problem with Stan is a program implementing the forward model's log density.  Stan uses derivative-based methods for optimization, sampling, and variational inference in order to scale with dimension.  It also contains a comprehensive suite of posterior analysis tools for summarizing fits to data.</span>
<span id="cb38-73"><a href="#cb38-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-74"><a href="#cb38-74" aria-hidden="true" tabindex="-1"></a>@barmherzig2022 used two different optimizers for maximum likelihood inference, conjugate gradient and trust regions. We will employ limited memory quasi-Newton optimization in the form of the limited-memory BFGS (L-BFGS) optimizer <span class="co">[</span><span class="ot">@zhu1997</span><span class="co">]</span>, which tends to outperform both conjugate gradient and trust-region methods for relatively simple optimization problems in moderately high dimensions like this one.  If the model adjusts for the inverse log odds (logistic) transform, the optimizer produces a maximum a posteriori (MAP) estimate, whereas if the model does not adjust for the change of variables, the optimizer produces a penalized maximum likelihood estimate (MLE).</span>
<span id="cb38-75"><a href="#cb38-75" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- BMW: seems repetitive with above bulleted list? --&gt;</span></span>
<span id="cb38-76"><a href="#cb38-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-77"><a href="#cb38-77" aria-hidden="true" tabindex="-1"></a>We employ two different Bayesian methods for solving the inverse problem, variational Bayes (VB) and Markov chain Monte Carlo (MCMC) sampling.  For MCMC, we employ the no-U-turn sampler (NUTS) <span class="co">[</span><span class="ot">@hoffman2014</span><span class="co">]</span>, which is an adaptive form of Hamiltonian Monte Carlo (HMC).  With MCMC, the result is an exact posterior sampler for which estimation error goes to zero as sample size goes to infinity.  For variational Bayes, we employ Pathfinder <span class="co">[</span><span class="ot">@zhang2022</span><span class="co">]</span>.  With VB, the results are only approximate, and in particular, posterior uncertainty tends to be systematically underestimated because we minimize KL-divergence from the approximation to the target distribution.</span>
<span id="cb38-78"><a href="#cb38-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-79"><a href="#cb38-79" aria-hidden="true" tabindex="-1"></a><span class="fu">## Python boilerplate</span></span>
<span id="cb38-80"><a href="#cb38-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-81"><a href="#cb38-81" aria-hidden="true" tabindex="-1"></a>Generating the data requires the standard Python numerical libraries <span class="in">`scipy.stats`</span> and <span class="in">`numpy`</span>, as well as the plotting libraries <span class="in">`matplotlib`</span> and <span class="in">`plotnine`</span> to display results.  Stan is accessed through the <span class="in">`cmdstanpy`</span> interface.  There is also code for converting RGB-coded images to grayscale.</span>
<span id="cb38-82"><a href="#cb38-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-85"><a href="#cb38-85" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-86"><a href="#cb38-86" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmdstanpy <span class="im">as</span> csp</span>
<span id="cb38-87"><a href="#cb38-87" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb38-88"><a href="#cb38-88" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb38-89"><a href="#cb38-89" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb38-90"><a href="#cb38-90" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb38-91"><a href="#cb38-91" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.image <span class="im">as</span> mpimg</span>
<span id="cb38-92"><a href="#cb38-92" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb38-93"><a href="#cb38-93" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotnine <span class="im">as</span> pn</span>
<span id="cb38-94"><a href="#cb38-94" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb38-95"><a href="#cb38-95" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb38-96"><a href="#cb38-96" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb38-97"><a href="#cb38-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-98"><a href="#cb38-98" aria-hidden="true" tabindex="-1"></a><span class="co"># turn off warning and info messages from Stan</span></span>
<span id="cb38-99"><a href="#cb38-99" aria-hidden="true" tabindex="-1"></a>csp.utils.get_logger().setLevel(logging.ERROR)</span>
<span id="cb38-100"><a href="#cb38-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-101"><a href="#cb38-101" aria-hidden="true" tabindex="-1"></a><span class="co"># turn off warnings from plotnine</span></span>
<span id="cb38-102"><a href="#cb38-102" aria-hidden="true" tabindex="-1"></a>warnings.simplefilter(action<span class="op">=</span><span class="st">'ignore'</span>, category<span class="op">=</span><span class="pp">FutureWarning</span>)</span>
<span id="cb38-103"><a href="#cb38-103" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings( <span class="st">"ignore"</span>, module <span class="op">=</span> <span class="st">"plotnine\..*"</span> )</span>
<span id="cb38-104"><a href="#cb38-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-105"><a href="#cb38-105" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rgb2gray(rgb):</span>
<span id="cb38-106"><a href="#cb38-106" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert a nxmx3 RGB array to a grayscale nxm array.</span></span>
<span id="cb38-107"><a href="#cb38-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-108"><a href="#cb38-108" aria-hidden="true" tabindex="-1"></a><span class="co">    This function uses the same internal coefficients as MATLAB:</span></span>
<span id="cb38-109"><a href="#cb38-109" aria-hidden="true" tabindex="-1"></a><span class="co">    https://www.mathworks.com/help/matlab/ref/rgb2gray.html</span></span>
<span id="cb38-110"><a href="#cb38-110" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb38-111"><a href="#cb38-111" aria-hidden="true" tabindex="-1"></a>    r, g, b <span class="op">=</span> rgb[:, :, <span class="dv">0</span>], rgb[:, :, <span class="dv">1</span>], rgb[:, :, <span class="dv">2</span>]</span>
<span id="cb38-112"><a href="#cb38-112" aria-hidden="true" tabindex="-1"></a>    gray <span class="op">=</span> <span class="fl">0.2989</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.5870</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.1140</span> <span class="op">*</span> b</span>
<span id="cb38-113"><a href="#cb38-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-114"><a href="#cb38-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gray</span>
<span id="cb38-115"><a href="#cb38-115" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-116"><a href="#cb38-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-117"><a href="#cb38-117" aria-hidden="true" tabindex="-1"></a><span class="fu"># Test images</span></span>
<span id="cb38-118"><a href="#cb38-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-119"><a href="#cb38-119" aria-hidden="true" tabindex="-1"></a>For simplicity of exposition, we will restrict attention to black and white digital images at $256 \times 256$ pixel resolution.  The pixel values will be represented with continuous values in $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$, with $0$ being pure black and $1$ pure white. An image is thus an element $X \in <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>^{256 \times 256}.$  Compute time to evaluate the log density and gradients scales linearly in time and memory for each image dimension, which means it scales quadratically in $N$ for an $N \times N$ image.</span>
<span id="cb38-120"><a href="#cb38-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-121"><a href="#cb38-121" aria-hidden="true" tabindex="-1"></a><span class="fu">## Primary test image</span></span>
<span id="cb38-122"><a href="#cb38-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-123"><a href="#cb38-123" aria-hidden="true" tabindex="-1"></a>We will concentrate on the target image of a <span class="co">[</span><span class="ot">mimivirus</span><span class="co">](https://en.wikipedia.org/wiki/Mimivirus)</span>, a type of <span class="co">[</span><span class="ot">giant virus</span><span class="co">](https://en.wikipedia.org/wiki/Giant_virus)</span>. It is giant in the sense that its genome is over one million base pairs in length.  The mimivirus is structured as an icosahedral capsid of approximately 400nm with filaments extending another 100nm around the capsid.  An image is shown in @fig-mimivirus.</span>
<span id="cb38-124"><a href="#cb38-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-127"><a href="#cb38-127" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-128"><a href="#cb38-128" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Image of a mimivirus.  The capsid is an icosahedron 400nm across with 100nm filaments. Image copyright 2008 by E. Ghigo J. Kartenbeck, P. Lien, L. Pelkmans, C. Capo, J.L. Mege, and D. Raoult D. 2008, and distributed under the [CC BY 2.5](https://creativecommons.org/licenses/by/2.5) license.</span></span>
<span id="cb38-129"><a href="#cb38-129" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-mimivirus</span></span>
<span id="cb38-130"><a href="#cb38-130" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-131"><a href="#cb38-131" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-132"><a href="#cb38-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-133"><a href="#cb38-133" aria-hidden="true" tabindex="-1"></a>X_src <span class="op">=</span> rgb2gray(mpimg.imread(<span class="st">'img/mimivirus.png'</span>))</span>
<span id="cb38-134"><a href="#cb38-134" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb38-135"><a href="#cb38-135" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_src, cmap<span class="op">=</span><span class="st">'gray'</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-136"><a href="#cb38-136" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb38-137"><a href="#cb38-137" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb38-138"><a href="#cb38-138" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb38-139"><a href="#cb38-139" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb38-140"><a href="#cb38-140" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-141"><a href="#cb38-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-142"><a href="#cb38-142" aria-hidden="true" tabindex="-1"></a><span class="fu">## Secondary test images</span></span>
<span id="cb38-143"><a href="#cb38-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-144"><a href="#cb38-144" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- BMW: are these still planned? --&gt;</span></span>
<span id="cb38-145"><a href="#cb38-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-146"><a href="#cb38-146" aria-hidden="true" tabindex="-1"></a>In addition to the mimivirus image, we will also simulate and reconstruct the ten images show in @fig-test_img.</span>
<span id="cb38-147"><a href="#cb38-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-150"><a href="#cb38-150" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-151"><a href="#cb38-151" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Images form the USC/SIPI test repository.  First row, left to right) female [Bell Labs?], house, tree, jelly beans, moon surface.  Second row, left to right) aerial, airplane, clock, resolution chart, chemical plant.</span></span>
<span id="cb38-152"><a href="#cb38-152" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-test_img</span></span>
<span id="cb38-153"><a href="#cb38-153" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-154"><a href="#cb38-154" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-155"><a href="#cb38-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-156"><a href="#cb38-156" aria-hidden="true" tabindex="-1"></a>img_dir <span class="op">=</span> <span class="st">'img/usc-sipi'</span></span>
<span id="cb38-157"><a href="#cb38-157" aria-hidden="true" tabindex="-1"></a>image_files <span class="op">=</span> <span class="bu">sorted</span>([f <span class="cf">for</span> f <span class="kw">in</span> os.listdir(img_dir) <span class="cf">if</span> f.endswith(<span class="st">'.png'</span>)])</span>
<span id="cb38-158"><a href="#cb38-158" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">8</span>))</span>
<span id="cb38-159"><a href="#cb38-159" aria-hidden="true" tabindex="-1"></a>axs <span class="op">=</span> axs.ravel()</span>
<span id="cb38-160"><a href="#cb38-160" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axs):</span>
<span id="cb38-161"><a href="#cb38-161" aria-hidden="true" tabindex="-1"></a>    img_path <span class="op">=</span> os.path.join(img_dir, image_files[i])</span>
<span id="cb38-162"><a href="#cb38-162" aria-hidden="true" tabindex="-1"></a>    gray_img <span class="op">=</span> mpimg.imread(img_path)</span>
<span id="cb38-163"><a href="#cb38-163" aria-hidden="true" tabindex="-1"></a>    ax.imshow(gray_img, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb38-164"><a href="#cb38-164" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb38-165"><a href="#cb38-165" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb38-166"><a href="#cb38-166" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb38-167"><a href="#cb38-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-168"><a href="#cb38-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-169"><a href="#cb38-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-170"><a href="#cb38-170" aria-hidden="true" tabindex="-1"></a><span class="fu"># The generative model</span></span>
<span id="cb38-171"><a href="#cb38-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-172"><a href="#cb38-172" aria-hidden="true" tabindex="-1"></a><span class="fu">## Image and photon sensor representations</span></span>
<span id="cb38-173"><a href="#cb38-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-174"><a href="#cb38-174" aria-hidden="true" tabindex="-1"></a>An image is represented by a random matrix of continuous pixel values between 0 and 1,</span>
<span id="cb38-175"><a href="#cb38-175" aria-hidden="true" tabindex="-1"></a>$X \in <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>^{N \times N}$.  Typically we will be using a representation that excludes the endpoints other than through numerical underflow or rounding. <span class="co">&lt;!-- BMW: should we be re-quantizing our images do we think? --&gt;</span> The photons measured at the sensor are represented by a random matrix of discrete counts for the sensor grid, $Y \in \mathbb{N}^{M_1 \times M_2}.$</span>
<span id="cb38-176"><a href="#cb38-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-177"><a href="#cb38-177" aria-hidden="true" tabindex="-1"></a><span class="fu">## Unconstrained representation and change of variables correction</span></span>
<span id="cb38-178"><a href="#cb38-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-179"><a href="#cb38-179" aria-hidden="true" tabindex="-1"></a>It is more convenient for both sampling and optimization to work over an unconstrained parameterization with support in all of $\mathbb{R}^D$ for some $D.$  As an alternative to the constrained image representation $X$, consider the smooth, bijective, and strictly monotonic log odds transform applied elementwise,</span>
<span id="cb38-180"><a href="#cb38-180" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-181"><a href="#cb38-181" aria-hidden="true" tabindex="-1"></a>U = \textrm{logit}(X),</span>
<span id="cb38-182"><a href="#cb38-182" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-183"><a href="#cb38-183" aria-hidden="true" tabindex="-1"></a>where</span>
<span id="cb38-184"><a href="#cb38-184" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-185"><a href="#cb38-185" aria-hidden="true" tabindex="-1"></a>\textrm{logit}(v) = \log \left( \frac{v}{1 - v} \right)</span>
<span id="cb38-186"><a href="#cb38-186" aria-hidden="true" tabindex="-1"></a>\qquad</span>
<span id="cb38-187"><a href="#cb38-187" aria-hidden="true" tabindex="-1"></a>\textrm{logit}^{-1}(u) = \frac{1}{1 + \exp(-u)}.</span>
<span id="cb38-188"><a href="#cb38-188" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-189"><a href="#cb38-189" aria-hidden="true" tabindex="-1"></a>If $p_X$ has support on $(0, 1)^{N \times N},$ then $p_U$ has support on all of $\mathbb{R}^{N \times N}.$  The density of $U$ is given by the change of variables formula,</span>
<span id="cb38-190"><a href="#cb38-190" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-191"><a href="#cb38-191" aria-hidden="true" tabindex="-1"></a>p_U(u) = p_X(\textrm{logit}^{-1}(u)) \cdot \left| \prod_{i, j} (\textrm{logit}^{-1})'(u_{i,j}) \right|,</span>
<span id="cb38-192"><a href="#cb38-192" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-193"><a href="#cb38-193" aria-hidden="true" tabindex="-1"></a>where the derivative of the logistic sigmoid $\textrm{logit}^{-1}$ is</span>
<span id="cb38-194"><a href="#cb38-194" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-195"><a href="#cb38-195" aria-hidden="true" tabindex="-1"></a>\left(\textrm{logit}^{-1}\right)'(u)</span>
<span id="cb38-196"><a href="#cb38-196" aria-hidden="true" tabindex="-1"></a>= \textrm{logit}^{-1}(u) \cdot \left( 1 - \textrm{logit}^{-1}(u) \right).</span>
<span id="cb38-197"><a href="#cb38-197" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-198"><a href="#cb38-198" aria-hidden="true" tabindex="-1"></a>On the log scale,</span>
<span id="cb38-199"><a href="#cb38-199" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-200"><a href="#cb38-200" aria-hidden="true" tabindex="-1"></a>\log p_U(u) = \log p_X(\textrm{logit}^{-1}(u))</span>
<span id="cb38-201"><a href="#cb38-201" aria-hidden="true" tabindex="-1"></a><span class="ss"> + </span>\sum_{i, j} \log \left( (\textrm{logit}^{-1})'(u_{i,j}) \right).</span>
<span id="cb38-202"><a href="#cb38-202" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-203"><a href="#cb38-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-204"><a href="#cb38-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-205"><a href="#cb38-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-206"><a href="#cb38-206" aria-hidden="true" tabindex="-1"></a><span class="fu">## Generative process overview</span></span>
<span id="cb38-207"><a href="#cb38-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-208"><a href="#cb38-208" aria-hidden="true" tabindex="-1"></a>The first step is to generate an image from the prior,</span>
<span id="cb38-209"><a href="#cb38-209" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-210"><a href="#cb38-210" aria-hidden="true" tabindex="-1"></a>x \sim p_X\,(\cdot).</span>
<span id="cb38-211"><a href="#cb38-211" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-212"><a href="#cb38-212" aria-hidden="true" tabindex="-1"></a>Then, given the image $x$, the second and final step is to generate the photons observed at the sensors $y$ conditioned on the image $x,$ using the sampling distribution,</span>
<span id="cb38-213"><a href="#cb38-213" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-214"><a href="#cb38-214" aria-hidden="true" tabindex="-1"></a>y \sim p_{Y \mid X}\,(\cdot \mid x).</span>
<span id="cb38-215"><a href="#cb38-215" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-216"><a href="#cb38-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-217"><a href="#cb38-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-218"><a href="#cb38-218" aria-hidden="true" tabindex="-1"></a><span class="fu">## The prior</span></span>
<span id="cb38-219"><a href="#cb38-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-220"><a href="#cb38-220" aria-hidden="true" tabindex="-1"></a><span class="fu">### Uniform prior is possible</span></span>
<span id="cb38-221"><a href="#cb38-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-222"><a href="#cb38-222" aria-hidden="true" tabindex="-1"></a>Because the space $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>^{256 \times 256}$ has finite hypervolume, it would be possible to use a uniform prior over pixel values, $p_X(x) \propto 1.$  At the other extreme, it would also be possible to introduce a meaningful natural image prior <span class="co">[</span><span class="ot">@kadkhodaie2021</span><span class="co">]</span>, a promising modern approach to which is based on diffusion models <span class="co">[</span><span class="ot">@graikos2022; @fei2023</span><span class="co">]</span>.</span>
<span id="cb38-223"><a href="#cb38-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-224"><a href="#cb38-224" aria-hidden="true" tabindex="-1"></a><span class="fu">### ICAR prior in constrained space</span></span>
<span id="cb38-225"><a href="#cb38-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-226"><a href="#cb38-226" aria-hidden="true" tabindex="-1"></a>Instead of a uniform prior or natural image prior, we will use a simple intrinsic conditional autoregressive (ICAR) prior <span class="co">[</span><span class="ot">@besag1991</span><span class="co">]</span>, which penalizes differences between adjacent pixels according to a scale $\sigma &gt; 0.$ These priors were originally developed for image denoising. The ICAR prior is defined by</span>
<span id="cb38-227"><a href="#cb38-227" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-228"><a href="#cb38-228" aria-hidden="true" tabindex="-1"></a>p_X(x) \propto \prod_{(m, n) \sim (m', n')} \textrm{normal}(x_{m,n} \mid x_{m',n'}, \ \sigma),</span>
<span id="cb38-229"><a href="#cb38-229" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-230"><a href="#cb38-230" aria-hidden="true" tabindex="-1"></a>where $\sim$ is the adjacency relationship defined to be unique so that  $(m, n) \sim (m + 1, n)$ for $m &lt; 256$ and $(m, n) \sim (m, n + 1)$ for $n &lt; 256$, and where $\sigma$ is the scale of the normal distribution.  This density $p_X$ can, in theory, be normalized within the space $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>^{256 \times 256},$ but that is not going to be necessary for any of the inference methods we use.  It would also be possible to smooth along the diagonals by including an adjacency relation $(m, n) \sim (m + 1, n + 1)$ for $m, n &lt; 256,$ but we do not evaluate that option here.</span>
<span id="cb38-231"><a href="#cb38-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-232"><a href="#cb38-232" aria-hidden="true" tabindex="-1"></a>Because we will be sampling using the unconstrained space $U,$ we apply the change of variables from $X$ to derive the density in the unconstrained space,</span>
<span id="cb38-233"><a href="#cb38-233" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb38-234"><a href="#cb38-234" aria-hidden="true" tabindex="-1"></a>p_U(u) \propto { } &amp;</span>
<span id="cb38-235"><a href="#cb38-235" aria-hidden="true" tabindex="-1"></a>\prod_{(m, n) \sim (m', n')}</span>
<span id="cb38-236"><a href="#cb38-236" aria-hidden="true" tabindex="-1"></a>\textrm{normal}<span class="sc">\!</span>\left(\textrm{logit}^{-1}(u_{m,n}) \mid \textrm{logit}^{-1}(u_{m',n'}), \ \sigma\right)</span>
<span id="cb38-237"><a href="#cb38-237" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb38-238"><a href="#cb38-238" aria-hidden="true" tabindex="-1"></a>&amp;</span>
<span id="cb38-239"><a href="#cb38-239" aria-hidden="true" tabindex="-1"></a>\hspace*{1em} \cdot \prod_{m, n} \textrm{logit}^{-1}(u_{m, n}) \cdot (1 - \textrm{logit}^{-1}(u_{m,n})).</span>
<span id="cb38-240"><a href="#cb38-240" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb38-241"><a href="#cb38-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-242"><a href="#cb38-242" aria-hidden="true" tabindex="-1"></a><span class="fu">### ICAR prior in unconstrained space</span></span>
<span id="cb38-243"><a href="#cb38-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-244"><a href="#cb38-244" aria-hidden="true" tabindex="-1"></a>An ICAR prior may also be placed directly on the unconstrained values,</span>
<span id="cb38-245"><a href="#cb38-245" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-246"><a href="#cb38-246" aria-hidden="true" tabindex="-1"></a>p_U(u) \propto \prod_{(m, n) \sim (m', n')} \textrm{normal}(u_{m,n} \mid u_{m',n'}, \ \tau),</span>
<span id="cb38-247"><a href="#cb38-247" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-248"><a href="#cb38-248" aria-hidden="true" tabindex="-1"></a>with $\tau$ being the scale of variation of the unconstrained parameters.  As before, $X = \textrm{logit}^{-1}(u)$ recovers the pixel values for use downstream in the model.  Conveniently, when parameterized this way, the Jacobian adjustment is not necessary because a distribution is not being placed on the constrained parameters.  This approach would not be feasible for natural image priors placed directly on $X$.</span>
<span id="cb38-249"><a href="#cb38-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-250"><a href="#cb38-250" aria-hidden="true" tabindex="-1"></a><span class="fu">## The sampling distribution</span></span>
<span id="cb38-251"><a href="#cb38-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-252"><a href="#cb38-252" aria-hidden="true" tabindex="-1"></a>The sampling distribution proceeds in several stages.  First, the image is combined with a separator and a reference image and then padded.  The result defines the shape of the sensor grid.  Next, a discrete Fourier transform is applied to the padded and separated image and reference, the squared absolute values of which determine the proportion of photons that are expected to arrive at the specified sensor.  Then a beamstop is applied to the model where it is applied in practice to prevent damage to the sample or sensors.  Finally, the expected proportions are normalized for the intensity of the beam and then the photons are generated according to a simple Poisson process.</span>
<span id="cb38-253"><a href="#cb38-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-254"><a href="#cb38-254" aria-hidden="true" tabindex="-1"></a><span class="fu">### The reference image</span></span>
<span id="cb38-255"><a href="#cb38-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-256"><a href="#cb38-256" aria-hidden="true" tabindex="-1"></a>For the experiments here, we use an idealized optimal reference image $R$, the uniformly redundant array (URA) reference <span class="co">[</span><span class="ot">@fenimore1978</span><span class="co">]</span>; see @fig-ura.  The URA has been shown to be an optimal reference image for this kind of work.   We use the <span class="co">[</span><span class="ot">codedapertures</span><span class="co">](https://github.com/bpops/codedapertures)</span> package to generate a URA of appropriate size.   The URA is black and white (i.e., no intermediate gray values), and it has the same dimensions ($256 \times 256$) as the image being inferred. It will be supplied as data, so that other references can be swapped in depending on the actual reference image being used (e.g., a square cutout, a pinhole, or no reference at all).</span>
<span id="cb38-257"><a href="#cb38-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-260"><a href="#cb38-260" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-261"><a href="#cb38-261" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Uniformly redundant array. This reference image is optimal for identification through phase retrieval. Other reference images may be used with the same code and model.</span></span>
<span id="cb38-262"><a href="#cb38-262" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-ura</span></span>
<span id="cb38-263"><a href="#cb38-263" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-264"><a href="#cb38-264" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-265"><a href="#cb38-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-266"><a href="#cb38-266" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> codedapertures</span>
<span id="cb38-267"><a href="#cb38-267" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> codedapertures.ura(rank<span class="op">=</span><span class="dv">16</span>).aperture[:<span class="dv">256</span>,:<span class="dv">256</span>]</span>
<span id="cb38-268"><a href="#cb38-268" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb38-269"><a href="#cb38-269" aria-hidden="true" tabindex="-1"></a>plt.imshow(R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb38-270"><a href="#cb38-270" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb38-271"><a href="#cb38-271" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb38-272"><a href="#cb38-272" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb38-273"><a href="#cb38-273" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb38-274"><a href="#cb38-274" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-275"><a href="#cb38-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-276"><a href="#cb38-276" aria-hidden="true" tabindex="-1"></a><span class="fu">### The seperator and reference image</span></span>
<span id="cb38-277"><a href="#cb38-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-278"><a href="#cb38-278" aria-hidden="true" tabindex="-1"></a>There is also a purely black separator of the same size as the image, which we will use $Z$ to denote because it is full of zero values.  Like the reference pattern, this separator is typically chosen to be the same size as the specimen, so that its width $d$ is equal to $N,$ the pixel width of the image.  The image $X$ will be concatenated left-to-right (i.e., by column) with the separator $Z$ and the reference image $R$, and the result will be doenoted as <span class="in">`X_Z_R`</span> in the code.</span>
<span id="cb38-279"><a href="#cb38-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-282"><a href="#cb38-282" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-283"><a href="#cb38-283" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Source image, zero separator, and reference image concatenated.</span></span>
<span id="cb38-284"><a href="#cb38-284" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-separator</span></span>
<span id="cb38-285"><a href="#cb38-285" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-286"><a href="#cb38-286" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-287"><a href="#cb38-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-288"><a href="#cb38-288" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> np.shape(X_src)[<span class="dv">0</span>]</span>
<span id="cb38-289"><a href="#cb38-289" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> N</span>
<span id="cb38-290"><a href="#cb38-290" aria-hidden="true" tabindex="-1"></a>X_Z_R <span class="op">=</span> np.concatenate([X_src, np.zeros((N, d)), R], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-291"><a href="#cb38-291" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">3</span>))</span>
<span id="cb38-292"><a href="#cb38-292" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_Z_R, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb38-293"><a href="#cb38-293" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">511</span>, <span class="dv">767</span>], [<span class="dv">1</span>, <span class="dv">256</span>, <span class="dv">512</span>, <span class="dv">768</span>])</span>
<span id="cb38-294"><a href="#cb38-294" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">127</span>, <span class="dv">255</span>], [<span class="dv">1</span>, <span class="dv">128</span>, <span class="dv">256</span>])</span>
<span id="cb38-295"><a href="#cb38-295" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb38-296"><a href="#cb38-296" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb38-297"><a href="#cb38-297" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-298"><a href="#cb38-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-299"><a href="#cb38-299" aria-hidden="true" tabindex="-1"></a>It is this combination of image, separator, and reference are the ones subjected to a beam of X-rays.</span>
<span id="cb38-300"><a href="#cb38-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-301"><a href="#cb38-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-302"><a href="#cb38-302" aria-hidden="true" tabindex="-1"></a><span class="fu">### Padding</span></span>
<span id="cb38-303"><a href="#cb38-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-304"><a href="#cb38-304" aria-hidden="true" tabindex="-1"></a>The original image, separator and reference image are next padded to the right and below up to a size of $M_1 \times M_2$.  Sensors are placed at each position in the padded matrix.  The padding has the effect of interpolating in image space.  Let</span>
<span id="cb38-305"><a href="#cb38-305" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-306"><a href="#cb38-306" aria-hidden="true" tabindex="-1"></a>P = \textrm{pad}(\textrm{cat}(X^{\textrm{src}}, Z, R), M_1, M_2)</span>
<span id="cb38-307"><a href="#cb38-307" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-308"><a href="#cb38-308" aria-hidden="true" tabindex="-1"></a>be the padded version of the image, separator, and reference image, where $X^{\textrm{src}}$ is the source image, $Z$ is a zero matrix, and $R$ is the reference image.  The padding is taken to be twice the size of the material imaged, so that $M_1 = 6 \cdot 256$ and $M_2 = 2 \cdot 256,$ which brings the total number of sensors to 786,432, just shy of one megapixel.</span>
<span id="cb38-309"><a href="#cb38-309" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- BMW: mention that padding can be smaller? see section 5 of @barmherzig2022 --&gt;</span></span>
<span id="cb38-310"><a href="#cb38-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-311"><a href="#cb38-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-312"><a href="#cb38-312" aria-hidden="true" tabindex="-1"></a><span class="fu">### Fourier transform shift</span></span>
<span id="cb38-313"><a href="#cb38-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-314"><a href="#cb38-314" aria-hidden="true" tabindex="-1"></a>Most fast Fourier transform (FFT) interfaces, including those in Stan, Matlab, and Python, return a shifted result with positive and negative values.  Specifically, values increase in frequency until $N,$ at which point a mirror image copy with negative indexes is appended to the end.  This produces the following order of indexes.</span>
<span id="cb38-315"><a href="#cb38-315" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-316"><a href="#cb38-316" aria-hidden="true" tabindex="-1"></a>0, 1, \ldots, N, -N, -N + 1, \ldots, -1.</span>
<span id="cb38-317"><a href="#cb38-317" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-318"><a href="#cb38-318" aria-hidden="true" tabindex="-1"></a>To get centered values, these are circularly shifted until the lowest frequency, represented at position 0, is in the middle,</span>
<span id="cb38-319"><a href="#cb38-319" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-320"><a href="#cb38-320" aria-hidden="true" tabindex="-1"></a>-N, -N + 1, \ldots -1, 0, 1, \ldots, N-1, N.</span>
<span id="cb38-321"><a href="#cb38-321" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-322"><a href="#cb38-322" aria-hidden="true" tabindex="-1"></a>With a two dimensional FFT, this happens twice, once for the rows and once for the columns.  This results in a horizontal and vertical shift, which is why the <span class="in">`fftshift`</span> operation swaps the diagonal blocks.  This can be illustrated with the following code, which creates a matrix of distinct entries, shifts it, then inverse shifts it back.  Assuming $A, B, C, D$ are matrices with conforming shapes (for building one big matrix), then</span>
<span id="cb38-323"><a href="#cb38-323" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-324"><a href="#cb38-324" aria-hidden="true" tabindex="-1"></a>\textrm{fftshift}\left(</span>
<span id="cb38-325"><a href="#cb38-325" aria-hidden="true" tabindex="-1"></a>\begin{bmatrix}</span>
<span id="cb38-326"><a href="#cb38-326" aria-hidden="true" tabindex="-1"></a>A &amp; B</span>
<span id="cb38-327"><a href="#cb38-327" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb38-328"><a href="#cb38-328" aria-hidden="true" tabindex="-1"></a>C &amp; D</span>
<span id="cb38-329"><a href="#cb38-329" aria-hidden="true" tabindex="-1"></a>\end{bmatrix}</span>
<span id="cb38-330"><a href="#cb38-330" aria-hidden="true" tabindex="-1"></a>\right)</span>
<span id="cb38-331"><a href="#cb38-331" aria-hidden="true" tabindex="-1"></a>=</span>
<span id="cb38-332"><a href="#cb38-332" aria-hidden="true" tabindex="-1"></a>\begin{bmatrix}</span>
<span id="cb38-333"><a href="#cb38-333" aria-hidden="true" tabindex="-1"></a>D &amp; C</span>
<span id="cb38-334"><a href="#cb38-334" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span></span>
<span id="cb38-335"><a href="#cb38-335" aria-hidden="true" tabindex="-1"></a>B &amp; A</span>
<span id="cb38-336"><a href="#cb38-336" aria-hidden="true" tabindex="-1"></a>\end{bmatrix}</span>
<span id="cb38-337"><a href="#cb38-337" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-338"><a href="#cb38-338" aria-hidden="true" tabindex="-1"></a>The elements are swapped across the diagonals, or equivalently, cyclically rotated in the horizontal direction, then in the vertical direction.  Consider the following concrete example matrix.</span>
<span id="cb38-339"><a href="#cb38-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-342"><a href="#cb38-342" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-343"><a href="#cb38-343" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb38-344"><a href="#cb38-344" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.ones((K, K), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb38-345"><a href="#cb38-345" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb38-346"><a href="#cb38-346" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb38-347"><a href="#cb38-347" aria-hidden="true" tabindex="-1"></a>        A[i, j] <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j</span>
<span id="cb38-348"><a href="#cb38-348" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"A =</span><span class="ch">\n</span><span class="sc">{</span>A<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb38-349"><a href="#cb38-349" aria-hidden="true" tabindex="-1"></a>A_shift <span class="op">=</span> np.fft.fftshift(A)</span>
<span id="cb38-350"><a href="#cb38-350" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-351"><a href="#cb38-351" aria-hidden="true" tabindex="-1"></a>Shifting it produces the following shifted matrix, where the center elements move to the corners and vice-versa.</span>
<span id="cb38-354"><a href="#cb38-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-355"><a href="#cb38-355" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"fftshift(A) =</span><span class="ch">\n</span><span class="sc">{</span>A_shift<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb38-356"><a href="#cb38-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-357"><a href="#cb38-357" aria-hidden="true" tabindex="-1"></a>Shifting back returns the original matrix.</span>
<span id="cb38-360"><a href="#cb38-360" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-361"><a href="#cb38-361" aria-hidden="true" tabindex="-1"></a>A_shift_ishift <span class="op">=</span> np.fft.ifftshift(A_shift)</span>
<span id="cb38-362"><a href="#cb38-362" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ifftshift(fftshift(A)) =</span><span class="ch">\n</span><span class="sc">{</span>A_shift_ishift<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb38-363"><a href="#cb38-363" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-364"><a href="#cb38-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-365"><a href="#cb38-365" aria-hidden="true" tabindex="-1"></a><span class="fu">### Fourier transform</span></span>
<span id="cb38-366"><a href="#cb38-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-367"><a href="#cb38-367" aria-hidden="true" tabindex="-1"></a>The concatenated and padded image $P$ is next put through a discrete, two-dimensional fast Fourier transform (FFT), which produces a complex matix of values.  These complex values, which have real and imaginary components, are then reduced to their real absolute value (aka magnitude).  The complex absolute value is the hypoteneuse of their real and imaginary components, but the angle, or phase, is lost.  This is why the problem of inferring the image from its Fourier transform is known as a phase-retrieval problem.  The absolute value is then squared, resulting in a matrix of values that is proportional to the expected intensity of sensor readings given the image, separator, reference, and padding,</span>
<span id="cb38-368"><a href="#cb38-368" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-369"><a href="#cb38-369" aria-hidden="true" tabindex="-1"></a>V = \big| \, \textrm{fft2}(P) \, \big|^2.</span>
<span id="cb38-370"><a href="#cb38-370" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-371"><a href="#cb38-371" aria-hidden="true" tabindex="-1"></a>$P$ has shape $512 \times 1536,$ so the two-dimensional FFT requires 1536 one-dimensional FFTs of size 512 and 512 one-dimensional FFTs of size 1536.  @fig-fftout shows a visualization of $V$, after the FFT shift to center the low frequencies.  The expected photon flux defines a lovely tartan pattern with horizontal and vertical reflection symmetries and a starburst in the center, which indicates the high expected photon flux in the low frequencies (which have been shifted to the center).</span>
<span id="cb38-372"><a href="#cb38-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-375"><a href="#cb38-375" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-376"><a href="#cb38-376" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Squared magnitudes of the FFT of the concatenated and padded image.  The low frequencies have been shifted to the center and the reflective symmetries show how the two-dimensional FFT has horizontal and vertical reflection symmetry. The bright spot in the middle shows the high expected photon flux in the low frequencies.  The plot is scaled to $\log (1 + V)$ in order to display the pattern.</span></span>
<span id="cb38-377"><a href="#cb38-377" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-fftout</span></span>
<span id="cb38-378"><a href="#cb38-378" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-379"><a href="#cb38-379" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-380"><a href="#cb38-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-381"><a href="#cb38-381" aria-hidden="true" tabindex="-1"></a>M1 <span class="op">=</span> <span class="dv">256</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb38-382"><a href="#cb38-382" aria-hidden="true" tabindex="-1"></a>M2 <span class="op">=</span> <span class="dv">256</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb38-383"><a href="#cb38-383" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.fft2(X_Z_R, s<span class="op">=</span>(M1, M2)))<span class="op">**</span><span class="dv">2</span></span>
<span id="cb38-384"><a href="#cb38-384" aria-hidden="true" tabindex="-1"></a>log1pV <span class="op">=</span> np.fft.fftshift(np.log1p(V))</span>
<span id="cb38-385"><a href="#cb38-385" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>,<span class="dv">3</span>))</span>
<span id="cb38-386"><a href="#cb38-386" aria-hidden="true" tabindex="-1"></a>plt.imshow(log1pV, cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb38-387"><a href="#cb38-387" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">767</span>, <span class="dv">1535</span>], [<span class="dv">1</span>, <span class="dv">768</span>, <span class="dv">1536</span>])</span>
<span id="cb38-388"><a href="#cb38-388" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">511</span>], [<span class="dv">1</span>, <span class="dv">256</span>, <span class="dv">512</span>])</span>
<span id="cb38-389"><a href="#cb38-389" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb38-390"><a href="#cb38-390" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb38-391"><a href="#cb38-391" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-392"><a href="#cb38-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-393"><a href="#cb38-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-394"><a href="#cb38-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-395"><a href="#cb38-395" aria-hidden="true" tabindex="-1"></a><span class="fu">### Beamstop</span></span>
<span id="cb38-396"><a href="#cb38-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-397"><a href="#cb38-397" aria-hidden="true" tabindex="-1"></a>To prevent the coherent X-ray beam from destroying the sensors with high photon flux in the low frequencies, the frequency sensors are blocked with a beamstop.  This blockage means zero photons arrive at sensors in the stopped positions.  The image must be reconstructed from only the remaining sensors.</span>
<span id="cb38-398"><a href="#cb38-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-399"><a href="#cb38-399" aria-hidden="true" tabindex="-1"></a>The beamstop has a configurable radius $r$ and occludes an $(2 \cdot r - 1) \times (2 \cdot r - 1)$ square of censors.  These are placed at the low frequencies, which will be the center of the image when it is centered around zero. After the FFT shift is applied, the stopped regions move to the four corners (see the example in the previous section).</span>
<span id="cb38-400"><a href="#cb38-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-401"><a href="#cb38-401" aria-hidden="true" tabindex="-1"></a>The shifted beamstop can be directly encoded as a matrix with zero values everywhere other than the 1 values in the the top left corner ($r \times r$ block), top right ($r \times r - 1$ block), lower left ($r-1 \times r$ block) and lower right ($r - 1 \times r - 1$ block).  We will let $\textrm{beamstop}_{i, j}$ be equal to 1 if position $(i, j)$ is stopped (i.e., blocked) and 0 otherwise.  When pieced together, that's a $(2 \cdot r - 1) \times (2 \cdot r - 1)$ square that's stopped.  A plot of the beamstop is shown in @fig-beamstop.</span>
<span id="cb38-402"><a href="#cb38-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-405"><a href="#cb38-405" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-406"><a href="#cb38-406" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Illustration of beamstop before the shifting.  The solid blue rectangles occlude the low frequencies in the corners, so that photon flux is not measured at those positions.</span></span>
<span id="cb38-407"><a href="#cb38-407" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-beamstop</span></span>
<span id="cb38-408"><a href="#cb38-408" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-409"><a href="#cb38-409" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-410"><a href="#cb38-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-411"><a href="#cb38-411" aria-hidden="true" tabindex="-1"></a>plot <span class="op">=</span> (</span>
<span id="cb38-412"><a href="#cb38-412" aria-hidden="true" tabindex="-1"></a>  pn.ggplot()</span>
<span id="cb38-413"><a href="#cb38-413" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb38-414"><a href="#cb38-414" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb38-415"><a href="#cb38-415" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb38-416"><a href="#cb38-416" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb38-417"><a href="#cb38-417" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lower left</span></span>
<span id="cb38-418"><a href="#cb38-418" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-419"><a href="#cb38-419" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-420"><a href="#cb38-420" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-421"><a href="#cb38-421" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-422"><a href="#cb38-422" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">0</span>, xmax<span class="op">=</span><span class="dv">3</span>, ymin<span class="op">=</span><span class="dv">0</span>, ymax<span class="op">=</span><span class="dv">1</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb38-423"><a href="#cb38-423" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lower right</span></span>
<span id="cb38-424"><a href="#cb38-424" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-425"><a href="#cb38-425" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">1</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-426"><a href="#cb38-426" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">1</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-427"><a href="#cb38-427" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">0</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">0</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-428"><a href="#cb38-428" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">9</span>, xmax<span class="op">=</span><span class="dv">12</span>, ymin<span class="op">=</span><span class="dv">0</span>, ymax<span class="op">=</span><span class="dv">1</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb38-429"><a href="#cb38-429" aria-hidden="true" tabindex="-1"></a>  <span class="co"># upper left</span></span>
<span id="cb38-430"><a href="#cb38-430" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-431"><a href="#cb38-431" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-432"><a href="#cb38-432" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">3</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-433"><a href="#cb38-433" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">3</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">0</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-434"><a href="#cb38-434" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">0</span>, xmax<span class="op">=</span><span class="dv">3</span>, ymin<span class="op">=</span><span class="dv">3</span>, ymax<span class="op">=</span><span class="dv">4</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb38-435"><a href="#cb38-435" aria-hidden="true" tabindex="-1"></a>  <span class="co"># upper right</span></span>
<span id="cb38-436"><a href="#cb38-436" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-437"><a href="#cb38-437" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">9</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">4</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-438"><a href="#cb38-438" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">4</span>, xend<span class="op">=</span><span class="dv">12</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-439"><a href="#cb38-439" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_segment(pn.aes(x<span class="op">=</span><span class="dv">12</span>, y<span class="op">=</span><span class="dv">3</span>, xend<span class="op">=</span><span class="dv">9</span>, yend<span class="op">=</span><span class="dv">3</span>), color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb38-440"><a href="#cb38-440" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.geom_rect(pn.aes(xmin<span class="op">=</span><span class="dv">9</span>, xmax<span class="op">=</span><span class="dv">12</span>, ymin<span class="op">=</span><span class="dv">3</span>, ymax<span class="op">=</span><span class="dv">4</span>), fill<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb38-441"><a href="#cb38-441" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.scale_x_continuous(breaks<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">12</span>],</span>
<span id="cb38-442"><a href="#cb38-442" aria-hidden="true" tabindex="-1"></a>                          labels<span class="op">=</span>[<span class="st">"1"</span>, <span class="st">"r"</span>, <span class="st">"M1-r+2"</span>, <span class="st">"M1"</span>])</span>
<span id="cb38-443"><a href="#cb38-443" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.scale_y_continuous(breaks<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>],</span>
<span id="cb38-444"><a href="#cb38-444" aria-hidden="true" tabindex="-1"></a>                          labels<span class="op">=</span>[<span class="st">"1"</span>, <span class="st">"r"</span>, <span class="st">"M2-r+2"</span>, <span class="st">"M2"</span>])</span>
<span id="cb38-445"><a href="#cb38-445" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span> pn.theme(figure_size<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">2</span>),</span>
<span id="cb38-446"><a href="#cb38-446" aria-hidden="true" tabindex="-1"></a>             plot_background<span class="op">=</span>pn.element_rect(fill<span class="op">=</span><span class="st">"white"</span>),</span>
<span id="cb38-447"><a href="#cb38-447" aria-hidden="true" tabindex="-1"></a>             panel_background<span class="op">=</span>pn.element_rect(fill<span class="op">=</span><span class="st">"white"</span>),</span>
<span id="cb38-448"><a href="#cb38-448" aria-hidden="true" tabindex="-1"></a>             axis_title<span class="op">=</span>pn.element_blank(),</span>
<span id="cb38-449"><a href="#cb38-449" aria-hidden="true" tabindex="-1"></a>         axis_text_x<span class="op">=</span>pn.element_text(size<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">"black"</span>, angle<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb38-450"><a href="#cb38-450" aria-hidden="true" tabindex="-1"></a>             axis_text_y<span class="op">=</span>pn.element_text(size<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">"black"</span>),</span>
<span id="cb38-451"><a href="#cb38-451" aria-hidden="true" tabindex="-1"></a>         axis_ticks<span class="op">=</span>pn.element_blank(),</span>
<span id="cb38-452"><a href="#cb38-452" aria-hidden="true" tabindex="-1"></a>         axis_line<span class="op">=</span>pn.element_blank(),</span>
<span id="cb38-453"><a href="#cb38-453" aria-hidden="true" tabindex="-1"></a>             <span class="co"># axis_ticks_length_major=5,</span></span>
<span id="cb38-454"><a href="#cb38-454" aria-hidden="true" tabindex="-1"></a>         <span class="co"># axis_line=pn.element_line(color="black"),</span></span>
<span id="cb38-455"><a href="#cb38-455" aria-hidden="true" tabindex="-1"></a>             panel_grid<span class="op">=</span>pn.element_blank())</span>
<span id="cb38-456"><a href="#cb38-456" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb38-457"><a href="#cb38-457" aria-hidden="true" tabindex="-1"></a>plot</span>
<span id="cb38-458"><a href="#cb38-458" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-459"><a href="#cb38-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-460"><a href="#cb38-460" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- BMW: I'd still like to see the plot that is figure 5 with the beamstop added, for contrast, unless you have a strong objection. --&gt;</span></span>
<span id="cb38-461"><a href="#cb38-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-462"><a href="#cb38-462" aria-hidden="true" tabindex="-1"></a><span class="fu">### Normalization</span></span>
<span id="cb38-463"><a href="#cb38-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-464"><a href="#cb38-464" aria-hidden="true" tabindex="-1"></a>Let $N_p$ be the number of photons expected per sensor.  This is used like an exposure value in a Poisson model to set the scale of the expected photon counts, which are given by the vector $\lambda \in (0, \infty)^{M_1 \times M_2},$ defined by</span>
<span id="cb38-465"><a href="#cb38-465" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-466"><a href="#cb38-466" aria-hidden="true" tabindex="-1"></a>\lambda = \frac{N_p}{\textrm{mean}(V)} \cdot V.</span>
<span id="cb38-467"><a href="#cb38-467" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-468"><a href="#cb38-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-469"><a href="#cb38-469" aria-hidden="true" tabindex="-1"></a><span class="fu">### Poisson photon sampling</span></span>
<span id="cb38-470"><a href="#cb38-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-471"><a href="#cb38-471" aria-hidden="true" tabindex="-1"></a>Finally, the number of photons observed at each sensor in the grid is generated as a Poisson distribution, based on the expected photon flux  $\lambda,$</span>
<span id="cb38-472"><a href="#cb38-472" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-473"><a href="#cb38-473" aria-hidden="true" tabindex="-1"></a>Y_{i, j} \sim</span>
<span id="cb38-474"><a href="#cb38-474" aria-hidden="true" tabindex="-1"></a>\begin{cases}</span>
<span id="cb38-475"><a href="#cb38-475" aria-hidden="true" tabindex="-1"></a>\textrm{Poisson}(\lambda_{i, j}) &amp; \textrm{ if } \textrm{beamstop}(i, j) = 0</span>
<span id="cb38-476"><a href="#cb38-476" aria-hidden="true" tabindex="-1"></a><span class="sc">\\</span><span class="co">[</span><span class="ot">4pt</span><span class="co">]</span></span>
<span id="cb38-477"><a href="#cb38-477" aria-hidden="true" tabindex="-1"></a>\textrm{Poisson}(0) &amp; \textrm{ if } \textrm{beamstop}(i, j) = 1.</span>
<span id="cb38-478"><a href="#cb38-478" aria-hidden="true" tabindex="-1"></a>\end{cases}</span>
<span id="cb38-479"><a href="#cb38-479" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-480"><a href="#cb38-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-481"><a href="#cb38-481" aria-hidden="true" tabindex="-1"></a>A visualization of simulated $Y$ is shown (after being shifted) in @fig-simy.  The beamstop radius is set to $r = 13,$ so there is a $25 \times 25$ pixel square of sensors occluded by the beamstop.</span>
<span id="cb38-482"><a href="#cb38-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-485"><a href="#cb38-485" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-486"><a href="#cb38-486" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Sampled value of $Y$, which is distributed Poisson with rate $\lambda$.  The effect of the beamstop can be seen in the $25 \times 25$ pixel black square in the center, indicating a flux of zero. The scaled matrix $\log(1 + Y)$ is shown.</span></span>
<span id="cb38-487"><a href="#cb38-487" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simy</span></span>
<span id="cb38-488"><a href="#cb38-488" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-489"><a href="#cb38-489" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-490"><a href="#cb38-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-491"><a href="#cb38-491" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb38-492"><a href="#cb38-492" aria-hidden="true" tabindex="-1"></a>shifted_beamstop <span class="op">=</span> np.ones((M1, M2))  <span class="co"># 0 values are occluded</span></span>
<span id="cb38-493"><a href="#cb38-493" aria-hidden="true" tabindex="-1"></a>shifted_beamstop[M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M1 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r,</span>
<span id="cb38-494"><a href="#cb38-494" aria-hidden="true" tabindex="-1"></a>                 M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> r <span class="op">+</span> <span class="dv">1</span>: M2 <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> r] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb38-495"><a href="#cb38-495" aria-hidden="true" tabindex="-1"></a>beamstop <span class="op">=</span> np.fft.ifftshift(shifted_beamstop)</span>
<span id="cb38-496"><a href="#cb38-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-497"><a href="#cb38-497" aria-hidden="true" tabindex="-1"></a>N_p <span class="op">=</span> <span class="dv">1</span>  <span class="co"># expected number of photons per sensor</span></span>
<span id="cb38-498"><a href="#cb38-498" aria-hidden="true" tabindex="-1"></a>lambbda <span class="op">=</span> N_p <span class="op">/</span> V.mean() <span class="op">*</span> V</span>
<span id="cb38-499"><a href="#cb38-499" aria-hidden="true" tabindex="-1"></a>preY <span class="op">=</span> sp.stats.poisson.rvs(lambbda, random_state<span class="op">=</span><span class="dv">1234</span>)</span>
<span id="cb38-500"><a href="#cb38-500" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> np.array(preY <span class="op">*</span> beamstop, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb38-501"><a href="#cb38-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-502"><a href="#cb38-502" aria-hidden="true" tabindex="-1"></a>log1pY <span class="op">=</span> np.log1p(Y)</span>
<span id="cb38-503"><a href="#cb38-503" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>,<span class="dv">3</span>))</span>
<span id="cb38-504"><a href="#cb38-504" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.log1p(np.fft.fftshift(Y)), cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb38-505"><a href="#cb38-505" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>, <span class="dv">767</span>, <span class="dv">1535</span>], [<span class="dv">1</span>, <span class="dv">768</span>, <span class="dv">1536</span>])</span>
<span id="cb38-506"><a href="#cb38-506" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">511</span>], [<span class="dv">1</span>, <span class="dv">256</span>, <span class="dv">512</span>])</span>
<span id="cb38-507"><a href="#cb38-507" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb38-508"><a href="#cb38-508" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb38-509"><a href="#cb38-509" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-510"><a href="#cb38-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-511"><a href="#cb38-511" aria-hidden="true" tabindex="-1"></a>This completes the definition of the likelihood and with the prior, the forward model for simulating data.</span>
<span id="cb38-512"><a href="#cb38-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-513"><a href="#cb38-513" aria-hidden="true" tabindex="-1"></a><span class="fu"># Stan programs</span></span>
<span id="cb38-514"><a href="#cb38-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-515"><a href="#cb38-515" aria-hidden="true" tabindex="-1"></a>Stan is an imperative probabilistic programming langauge for statistical models coupled with tools for estimation and posterior analysis <span class="co">[</span><span class="ot">@carpenter2017</span><span class="co">]</span>. Stan's *Reference Manual* [@standev2024ref] contains complete details and the *User's Guide* <span class="co">[</span><span class="ot">@standev2024users</span><span class="co">]</span> provides guidance on usage.</span>
<span id="cb38-516"><a href="#cb38-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-517"><a href="#cb38-517" aria-hidden="true" tabindex="-1"></a>A Stan program defines the log posterior up to a normalizing constant, which is usually coded following Bayes's rule as the log joint density, \begin{equation}</span>
<span id="cb38-518"><a href="#cb38-518" aria-hidden="true" tabindex="-1"></a>\log p(x \mid y)</span>
<span id="cb38-519"><a href="#cb38-519" aria-hidden="true" tabindex="-1"></a>= \log p(y \mid x) + \log p(x) + \textrm{const},</span>
<span id="cb38-520"><a href="#cb38-520" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-521"><a href="#cb38-521" aria-hidden="true" tabindex="-1"></a>where $x$ is the vector of parameters representing the image and $y$ is the observed photon flux.  It reads the data in and then produces a C++ class that can evaluate the log density and use automatic differentiation to define gradients and Hessians <span class="co">[</span><span class="ot">@carpenter2015</span><span class="co">]</span>.  Stan's inference algorithms are all gradient-based for efficiency and scalability in dimension.  Stan is strongly statically typed, so all variables come with declarations of their type and size.  Stan is an imperative language like R <span class="co">[</span><span class="ot">@rteam2000</span><span class="co">]</span> or Python <span class="co">[</span><span class="ot">@vanrossum2010</span><span class="co">]</span>, rather than a declarative language like BUGS <span class="co">[</span><span class="ot">@lunn2013</span><span class="co">]</span>, so variables other than parameters being inferred must be defined before they are used.  Stan programs are organized into blocks for data, parameters, and the log density, plus transforms and predictive quantities.  Initially, we will present the constrained model and then later show the few lines that need to change to define an unconstrained model.  The full Stan programs are shown in the appendix.</span>
<span id="cb38-522"><a href="#cb38-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-523"><a href="#cb38-523" aria-hidden="true" tabindex="-1"></a><span class="fu">## The data declaration</span></span>
<span id="cb38-524"><a href="#cb38-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-525"><a href="#cb38-525" aria-hidden="true" tabindex="-1"></a>This is the block declaring all of the data variables that must be supplied externally.  The Stan variable names mirror those used in the mathematical definitions.</span>
<span id="cb38-526"><a href="#cb38-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-527"><a href="#cb38-527" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-528"><a href="#cb38-528" aria-hidden="true" tabindex="-1"></a><span class="in">data {</span></span>
<span id="cb38-529"><a href="#cb38-529" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=0&gt; N;                    // image dimension</span></span>
<span id="cb38-530"><a href="#cb38-530" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix&lt;lower=0, upper=1&gt;[N, N] R;  // registration image</span></span>
<span id="cb38-531"><a href="#cb38-531" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=0&gt; d;                    // separator width</span></span>
<span id="cb38-532"><a href="#cb38-532" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=N&gt; M1;                   // padded rows</span></span>
<span id="cb38-533"><a href="#cb38-533" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=2 * N + d&gt; M2;           // padded cols</span></span>
<span id="cb38-534"><a href="#cb38-534" aria-hidden="true" tabindex="-1"></a><span class="in">  int&lt;lower=0, upper=M1&gt; r;          // beamstop radius</span></span>
<span id="cb38-535"><a href="#cb38-535" aria-hidden="true" tabindex="-1"></a><span class="in">  real&lt;lower=0&gt; N_p;                 // avg photons per pixel</span></span>
<span id="cb38-536"><a href="#cb38-536" aria-hidden="true" tabindex="-1"></a><span class="in">  array[M1, M2] int&lt;lower=0&gt; Y;      // observed number of photons</span></span>
<span id="cb38-537"><a href="#cb38-537" aria-hidden="true" tabindex="-1"></a><span class="in">  real&lt;lower=0&gt; sigma;               // prior scale</span></span>
<span id="cb38-538"><a href="#cb38-538" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb38-539"><a href="#cb38-539" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-540"><a href="#cb38-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-541"><a href="#cb38-541" aria-hidden="true" tabindex="-1"></a>Stan programs begin execution by reading in the data variables and validating their constraints (e.g., <span class="in">`N`</span> being positive).</span>
<span id="cb38-542"><a href="#cb38-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-543"><a href="#cb38-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-544"><a href="#cb38-544" aria-hidden="true" tabindex="-1"></a><span class="fu">## Transformed data</span></span>
<span id="cb38-545"><a href="#cb38-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-546"><a href="#cb38-546" aria-hidden="true" tabindex="-1"></a>Stan programs allow transforms of data to be defined and saved.</span>
<span id="cb38-547"><a href="#cb38-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-548"><a href="#cb38-548" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-549"><a href="#cb38-549" aria-hidden="true" tabindex="-1"></a><span class="in">transformed data {</span></span>
<span id="cb38-550"><a href="#cb38-550" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[M1, M2] beamstop = beamstop_gen(M1, M2, r);  // beam stop</span></span>
<span id="cb38-551"><a href="#cb38-551" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[d, N] Z = rep_matrix(0, d, N);               // separator</span></span>
<span id="cb38-552"><a href="#cb38-552" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[N, N + d] Z_R = append_col(Z, R);            // separator + ref</span></span>
<span id="cb38-553"><a href="#cb38-553" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb38-554"><a href="#cb38-554" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-555"><a href="#cb38-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-556"><a href="#cb38-556" aria-hidden="true" tabindex="-1"></a>This involves three functions, only two of which are built-in, <span class="in">`rep_matrix`</span> to create the <span class="in">`d`</span> by <span class="in">`N`</span> matrix of zero values, and <span class="in">`append_col`</span> to append the zero padding (<span class="in">`Z`</span>) and reference image (<span class="in">`R`</span>, read in as data), together side by side. The function <span class="in">`beamstop_gen`</span> is user defined and given in its own block at the start of the program along with other functions that are necessary.</span>
<span id="cb38-557"><a href="#cb38-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-558"><a href="#cb38-558" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-559"><a href="#cb38-559" aria-hidden="true" tabindex="-1"></a><span class="in">functions {</span></span>
<span id="cb38-560"><a href="#cb38-560" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix beamstop_gen(int M1, int M2, int r) {</span></span>
<span id="cb38-561"><a href="#cb38-561" aria-hidden="true" tabindex="-1"></a><span class="in">    matrix[M1, M2] beamstop = rep_matrix(0, M1, M2);</span></span>
<span id="cb38-562"><a href="#cb38-562" aria-hidden="true" tabindex="-1"></a><span class="in">    if (r == 0) {</span></span>
<span id="cb38-563"><a href="#cb38-563" aria-hidden="true" tabindex="-1"></a><span class="in">      return beamstop;</span></span>
<span id="cb38-564"><a href="#cb38-564" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb38-565"><a href="#cb38-565" aria-hidden="true" tabindex="-1"></a><span class="in">    beamstop[1 : r, 1 : r] = rep_matrix(1, r, r);                // upper left</span></span>
<span id="cb38-566"><a href="#cb38-566" aria-hidden="true" tabindex="-1"></a><span class="in">    beamstop[1 : r, M2 - r + 2 : M2] = rep_matrix(1, r, r - 1);  // upper right</span></span>
<span id="cb38-567"><a href="#cb38-567" aria-hidden="true" tabindex="-1"></a><span class="in">    beamstop[M1 - r + 2 : M1, 1 : r] = rep_matrix(1, r - 1, r);  // lower left</span></span>
<span id="cb38-568"><a href="#cb38-568" aria-hidden="true" tabindex="-1"></a><span class="in">    beamstop[M1 - r + 2 : M1, M2 - r + 2 : M2]                   // lower right</span></span>
<span id="cb38-569"><a href="#cb38-569" aria-hidden="true" tabindex="-1"></a><span class="in">      = rep_matrix(1, r - 1, r - 1);</span></span>
<span id="cb38-570"><a href="#cb38-570" aria-hidden="true" tabindex="-1"></a><span class="in">    return beamstop;</span></span>
<span id="cb38-571"><a href="#cb38-571" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb38-572"><a href="#cb38-572" aria-hidden="true" tabindex="-1"></a><span class="in">  ...</span></span>
<span id="cb38-573"><a href="#cb38-573" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-574"><a href="#cb38-574" aria-hidden="true" tabindex="-1"></a>This function creates the shifted beamstop matrix by initializing a matrix of zeros of the size of the padding (<span class="in">`M1`</span> by <span class="in">`M2`</span>, given as arguments), then filling in the corners with 1 values based on the radius of the beamstop (<span class="in">`r`</span>).  There are other functions where the ellipses (<span class="in">`...`</span>) are shown here, and this block of functions appears first in the full Stan program before the data block.  The full Stan program in the index contains full function documentation for this and other user-defined functions appearing in the Stan program.</span>
<span id="cb38-575"><a href="#cb38-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-576"><a href="#cb38-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-577"><a href="#cb38-577" aria-hidden="true" tabindex="-1"></a><span class="fu">## Parameter declaration</span></span>
<span id="cb38-578"><a href="#cb38-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-579"><a href="#cb38-579" aria-hidden="true" tabindex="-1"></a>The parameters are declared but not defined.  During execution, parameter values are managed by the optimization or sampling algorithm and will thus be supplied to a Stan program externally.</span>
<span id="cb38-580"><a href="#cb38-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-581"><a href="#cb38-581" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-582"><a href="#cb38-582" aria-hidden="true" tabindex="-1"></a><span class="in">parameters {</span></span>
<span id="cb38-583"><a href="#cb38-583" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix&lt;lower=0, upper=1&gt;[N, N] X;    // image</span></span>
<span id="cb38-584"><a href="#cb38-584" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb38-585"><a href="#cb38-585" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-586"><a href="#cb38-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-587"><a href="#cb38-587" aria-hidden="true" tabindex="-1"></a>It is important that the bounds here, <span class="in">`lower=0`</span> and <span class="in">`upper=1`</span> are included on the parameter declaration.  These define the constrained domain for <span class="in">`X`</span>.  Stan operates with unconstrained parameters, so the variable <span class="in">`X`</span> will be implicitly log-odds transformed from $(0, 1)$ to $(-\infty, \infty)$ (Stan's intervals are open when going from unconstrained to constrained representations, but can wind up on th boundary due to arithmetic underflow or rounding).  Stan implicitly applies the change-of-variables correction for the inverse of the log-odds transform so that a prior may be placed directly on <span class="in">`X`</span> and propagate correctly to the unconstrained parameers <span class="in">`logit(X)`</span>.</span>
<span id="cb38-588"><a href="#cb38-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-589"><a href="#cb38-589" aria-hidden="true" tabindex="-1"></a><span class="fu">## The model block</span></span>
<span id="cb38-590"><a href="#cb38-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-591"><a href="#cb38-591" aria-hidden="true" tabindex="-1"></a>The model block defines the log density, adding terms to those already added through the Jacobian determinant of the unconstraining transform.</span>
<span id="cb38-592"><a href="#cb38-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-593"><a href="#cb38-593" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-594"><a href="#cb38-594" aria-hidden="true" tabindex="-1"></a><span class="in">model {</span></span>
<span id="cb38-595"><a href="#cb38-595" aria-hidden="true" tabindex="-1"></a><span class="in">  X ~ icar(sigma);</span></span>
<span id="cb38-596"><a href="#cb38-596" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[N, 2 * N + d] X_Z_R = append_col(X, Z_R);</span></span>
<span id="cb38-597"><a href="#cb38-597" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[M1, M2] V = square(abs(pad_fft2(X_Z_R, M1, M2)));</span></span>
<span id="cb38-598"><a href="#cb38-598" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[M1, M2] lambda = N_p / mean(V) * V;</span></span>
<span id="cb38-599"><a href="#cb38-599" aria-hidden="true" tabindex="-1"></a><span class="in">  for (m1 in 1 : M1) {</span></span>
<span id="cb38-600"><a href="#cb38-600" aria-hidden="true" tabindex="-1"></a><span class="in">    for (m2 in 1 : M2) {</span></span>
<span id="cb38-601"><a href="#cb38-601" aria-hidden="true" tabindex="-1"></a><span class="in">      if (!beamstop[m1, m2]) {</span></span>
<span id="cb38-602"><a href="#cb38-602" aria-hidden="true" tabindex="-1"></a><span class="in">        Y[m1, m2] ~ poisson(lambda[m1, m2]);</span></span>
<span id="cb38-603"><a href="#cb38-603" aria-hidden="true" tabindex="-1"></a><span class="in">      }</span></span>
<span id="cb38-604"><a href="#cb38-604" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb38-605"><a href="#cb38-605" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb38-606"><a href="#cb38-606" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb38-607"><a href="#cb38-607" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-608"><a href="#cb38-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-609"><a href="#cb38-609" aria-hidden="true" tabindex="-1"></a>The first line, <span class="in">`X ~ icar(sigma)`</span> says that <span class="in">`X`</span> has an ICAR prior.  The <span class="in">`icar`</span> distribution is not built into Stan, so it must be defined by the user.  Here's the definition.</span>
<span id="cb38-610"><a href="#cb38-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-611"><a href="#cb38-611" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-612"><a href="#cb38-612" aria-hidden="true" tabindex="-1"></a><span class="in">  real icar_lpdf(matrix X, real sigma) {</span></span>
<span id="cb38-613"><a href="#cb38-613" aria-hidden="true" tabindex="-1"></a><span class="in">    int M = rows(X);</span></span>
<span id="cb38-614"><a href="#cb38-614" aria-hidden="true" tabindex="-1"></a><span class="in">    int N = cols(X);</span></span>
<span id="cb38-615"><a href="#cb38-615" aria-hidden="true" tabindex="-1"></a><span class="in">    return normal_lpdf(to_vector(X[2:M, ]) | to_vector(X[1:M - 1, ]), sigma)</span></span>
<span id="cb38-616"><a href="#cb38-616" aria-hidden="true" tabindex="-1"></a><span class="in">      + normal_lpdf(to_vector(X[ , 2:N]) | to_vector(X[ , 1:N - 1]), sigma);</span></span>
<span id="cb38-617"><a href="#cb38-617" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb38-618"><a href="#cb38-618" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-619"><a href="#cb38-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-620"><a href="#cb38-620" aria-hidden="true" tabindex="-1"></a>Following the math, it's just a quadratic penalty on differences between row- and column-adjacent elements.  Stan allows vector slicing in the same way as MATLAB <span class="co">[</span><span class="ot">@MATLAB2024</span><span class="co">]</span> and R.  The variable <span class="in">`sigma`</span> controls the amount of regularization applied to adjacent elements; it is supplied as a data variable from the outside, though it could be fit in a hierarchical model.</span>
<span id="cb38-621"><a href="#cb38-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-622"><a href="#cb38-622" aria-hidden="true" tabindex="-1"></a>The second line of the model block defines the matrix <span class="in">`X_Z_R`</span> to be the result of concatenating the image (parameter <span class="in">`X`</span>) to the zero separator and reference image (<span class="in">`Z_R`</span>).  The third line defines the matrix <span class="in">`V`</span> to be the result of performing a two-dimensional FFT on the image, separator and reference padded out to <span class="in">`M1`</span> rows by zero-padding on the bottom and <span class="in">`M2`</span> columns by zero-padding on the right.  this is defined in the following user-defined function.</span>
<span id="cb38-623"><a href="#cb38-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-624"><a href="#cb38-624" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-625"><a href="#cb38-625" aria-hidden="true" tabindex="-1"></a><span class="in">  complex_matrix pad_fft2(complex_matrix Z, int N, int M) {</span></span>
<span id="cb38-626"><a href="#cb38-626" aria-hidden="true" tabindex="-1"></a><span class="in">    int r = rows(Z);</span></span>
<span id="cb38-627"><a href="#cb38-627" aria-hidden="true" tabindex="-1"></a><span class="in">    int c = cols(Z);</span></span>
<span id="cb38-628"><a href="#cb38-628" aria-hidden="true" tabindex="-1"></a><span class="in">    complex_matrix[N, M] pad = rep_matrix(0, N, M);</span></span>
<span id="cb38-629"><a href="#cb38-629" aria-hidden="true" tabindex="-1"></a><span class="in">    pad[1 : r, 1 : c] = Z;</span></span>
<span id="cb38-630"><a href="#cb38-630" aria-hidden="true" tabindex="-1"></a><span class="in">    return fft2(pad);</span></span>
<span id="cb38-631"><a href="#cb38-631" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb38-632"><a href="#cb38-632" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-633"><a href="#cb38-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-634"><a href="#cb38-634" aria-hidden="true" tabindex="-1"></a>This just pads the matrix with zeros, then applies the built-in two-dimensional FFT function to the padded image, separator, and reference (supplied as the argument <span class="in">`Z`</span>).  The result is a matrix of complex values.  The model expression then takes the absolue value of the complex matrix elemenetwise (which produces a real-valued matrix of the smae dimension), the result of which is squared elementwise to produce the matrix <span class="in">`V`</span>, the entries of which are proportional to the photon flux expected at that position.  The next line of the model defines <span class="in">`lambda`</span> by normalizing <span class="in">`V`</span> to the expected per-sensor photon count <span class="in">`N_p`</span>.</span>
<span id="cb38-635"><a href="#cb38-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-636"><a href="#cb38-636" aria-hidden="true" tabindex="-1"></a>The final lines of the model loop over the entries of the padded matrix which are not beamstopped and sample photons (<span class="in">`Y`</span>) with a Poisson distribution based on the rate (<span class="in">`lambda`</span>).  This defines the likelihood and completes the model specification, which has followed the mathematical definition of the forward model directly.</span>
<span id="cb38-637"><a href="#cb38-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-638"><a href="#cb38-638" aria-hidden="true" tabindex="-1"></a><span class="fu">## Alternative unconstrained model</span></span>
<span id="cb38-639"><a href="#cb38-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-640"><a href="#cb38-640" aria-hidden="true" tabindex="-1"></a>The unconstrained model is almost identical to the constrained-parameter model.  It defines an unconstrained representation of parameters, then transforms them in the transformed parameter block as follows:</span>
<span id="cb38-641"><a href="#cb38-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-642"><a href="#cb38-642" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-643"><a href="#cb38-643" aria-hidden="true" tabindex="-1"></a><span class="in">parameters {</span></span>
<span id="cb38-644"><a href="#cb38-644" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix[N, N] logit_X;  // log-odds transformed image</span></span>
<span id="cb38-645"><a href="#cb38-645" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb38-646"><a href="#cb38-646" aria-hidden="true" tabindex="-1"></a><span class="in">transformed parameters {</span></span>
<span id="cb38-647"><a href="#cb38-647" aria-hidden="true" tabindex="-1"></a><span class="in">  matrix&lt;lower=0, upper=1&gt;[N, N] X = inv_logit(logit_X);  // image</span></span>
<span id="cb38-648"><a href="#cb38-648" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb38-649"><a href="#cb38-649" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-650"><a href="#cb38-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-651"><a href="#cb38-651" aria-hidden="true" tabindex="-1"></a>The parameter for the model is now <span class="in">`logit_X`</span>, which is the log-odds transformed pixel value.  The constrained matrix <span class="in">`X`</span> is then defined in the transformed parameters block.  Here, the constraints in the transformed parameter block, like those in the data block, are just used for error checking---they are validated at the end of the block's execution and the iteration is rejected with an error message if the constraint fails.</span>
<span id="cb38-652"><a href="#cb38-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-653"><a href="#cb38-653" aria-hidden="true" tabindex="-1"></a>The only other difference is that the ICAR prior is placed directly on the log odds parameters in the model block,</span>
<span id="cb38-654"><a href="#cb38-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-655"><a href="#cb38-655" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-656"><a href="#cb38-656" aria-hidden="true" tabindex="-1"></a><span class="in">  logit_X ~ icar(sigma);</span></span>
<span id="cb38-657"><a href="#cb38-657" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-658"><a href="#cb38-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-659"><a href="#cb38-659" aria-hidden="true" tabindex="-1"></a>This changes the interpretation of <span class="in">`sigma`</span> from being on the pixel-value scale $(0, 1)$ to the unconstrained scale $(-\infty, \infty)$.  The values of <span class="in">`logit_X`</span> in practice will range between -10 and 10, the extremes of which correspond to nearly pure black and white, respectively.</span>
<span id="cb38-660"><a href="#cb38-660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-661"><a href="#cb38-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-662"><a href="#cb38-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-663"><a href="#cb38-663" aria-hidden="true" tabindex="-1"></a><span class="fu"># Estimation and Posterior Inference</span></span>
<span id="cb38-664"><a href="#cb38-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-665"><a href="#cb38-665" aria-hidden="true" tabindex="-1"></a>Given a Stan program for a model and the corresponding data, fitting the model is straightforward using cmdstanpy <span class="co">[</span><span class="ot">@standev2024csp</span><span class="co">]</span>.</span>
<span id="cb38-666"><a href="#cb38-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-667"><a href="#cb38-667" aria-hidden="true" tabindex="-1"></a><span class="fu">## Compiling the models</span></span>
<span id="cb38-668"><a href="#cb38-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-669"><a href="#cb38-669" aria-hidden="true" tabindex="-1"></a>The first thing to do is to compile the Stan model.  This is done by transpiling from Stan to C++, then compiling the C+ and linking against the rest of Stan's math library and algorithms.  This is all handled by the following CmdStanPy calls, one for the constrained and one for the unconstrained model.</span>
<span id="cb38-670"><a href="#cb38-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-673"><a href="#cb38-673" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-674"><a href="#cb38-674" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> csp.CmdStanModel(stan_file<span class="op">=</span><span class="st">'stan/holoCDI.stan'</span>)</span>
<span id="cb38-675"><a href="#cb38-675" aria-hidden="true" tabindex="-1"></a>model_unc <span class="op">=</span> csp.CmdStanModel(stan_file<span class="op">=</span><span class="st">'stan/holoCDI-unc.stan'</span>)</span>
<span id="cb38-676"><a href="#cb38-676" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-677"><a href="#cb38-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-678"><a href="#cb38-678" aria-hidden="true" tabindex="-1"></a><span class="fu">## Constructing the data dictionary</span></span>
<span id="cb38-679"><a href="#cb38-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-680"><a href="#cb38-680" aria-hidden="true" tabindex="-1"></a>CmdStanPy takes in data in the form of a Python dictionary.  The dictionary needs to define all the variables used in the Stan program and they have to be the right shapes to match the Stan declarations.  All of the constants have been defined and the data <span class="in">`Y`</span> has been simulated.  Here, the value for <span class="in">`sigma`</span> is defined to be 1; other prior scales are evaluated below.</span>
<span id="cb38-681"><a href="#cb38-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-684"><a href="#cb38-684" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-685"><a href="#cb38-685" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb38-686"><a href="#cb38-686" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb38-687"><a href="#cb38-687" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N"</span>: N, <span class="st">"R"</span>: R, <span class="st">"d"</span>: N, <span class="st">"M1"</span>: M1, <span class="st">"M2"</span>: M2, <span class="st">"r"</span>: r, <span class="st">"N_p"</span>: N_p,</span>
<span id="cb38-688"><a href="#cb38-688" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Y"</span>: Y, <span class="st">"sigma"</span>: sigma</span>
<span id="cb38-689"><a href="#cb38-689" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-690"><a href="#cb38-690" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-691"><a href="#cb38-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-692"><a href="#cb38-692" aria-hidden="true" tabindex="-1"></a><span class="fu">## Optimization-based point estimates</span></span>
<span id="cb38-693"><a href="#cb38-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-694"><a href="#cb38-694" aria-hidden="true" tabindex="-1"></a>In this section, Stan's optimizer is used to find point estimates as modes of a target density.  Stan uses L-BFGS <span class="co">[</span><span class="ot">@zhu1997</span><span class="co">]</span>, a limited-memory form of quasi-Newton optimization, which is a widely used black-box optimizer that uses finite-differences of the past few gradients to approximate a low-rank plus diagonal preconditioner dynamically during optimization.  This reduces linear algebra from the $\mathcal{O}(N^3)$ required for Newton's method to $\mathcal{O}(J^2 \cdot N),$ where $J$ is the rank of the preconditioner before adding the diagonal to make it positive definite.</span>
<span id="cb38-695"><a href="#cb38-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-696"><a href="#cb38-696" aria-hidden="true" tabindex="-1"></a><span class="fu">### Penalized maximum likelihood estimation</span></span>
<span id="cb38-697"><a href="#cb38-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-698"><a href="#cb38-698" aria-hidden="true" tabindex="-1"></a>Interpreting the ICAR prior as a quadratic penalty, a penalized maximum likelihood estimate (MLE) $x^*$ is defined by</span>
<span id="cb38-699"><a href="#cb38-699" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-700"><a href="#cb38-700" aria-hidden="true" tabindex="-1"></a>x^* = \textrm{arg max}_x \log p(y; \, x) + \log \textrm{icar}(x),</span>
<span id="cb38-701"><a href="#cb38-701" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-702"><a href="#cb38-702" aria-hidden="true" tabindex="-1"></a>but with no Jacobian adjustment for any change-of-variables used to constrain $x$ because $x$ is no longer considered to be a random variable (hence the semicolon in the notation).</span>
<span id="cb38-703"><a href="#cb38-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-704"><a href="#cb38-704" aria-hidden="true" tabindex="-1"></a>This estimate can be computed through optimization in Stan and extracted into a Python variable.</span>
<span id="cb38-705"><a href="#cb38-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-708"><a href="#cb38-708" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-709"><a href="#cb38-709" aria-hidden="true" tabindex="-1"></a>fit_mle <span class="op">=</span> model.optimize(data <span class="op">=</span> data, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">False</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb38-710"><a href="#cb38-710" aria-hidden="true" tabindex="-1"></a>X_hat_mle <span class="op">=</span> fit_mle.stan_variable(<span class="st">'X'</span>)</span>
<span id="cb38-711"><a href="#cb38-711" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-712"><a href="#cb38-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-713"><a href="#cb38-713" aria-hidden="true" tabindex="-1"></a>A random seed is hardcoded for reproducibility and initialiation is specified to be $\textrm{uniform}(-0.5, 0.5)$ on the unconstrained scale. The Jacobian adjustment for the constrained parameter is turned off here for computing the MLE.</span>
<span id="cb38-714"><a href="#cb38-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-715"><a href="#cb38-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-716"><a href="#cb38-716" aria-hidden="true" tabindex="-1"></a><span class="fu">### Maximum a posteriori estimation</span></span>
<span id="cb38-717"><a href="#cb38-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-718"><a href="#cb38-718" aria-hidden="true" tabindex="-1"></a>An alternative point estimation strategy can be derived by taking the point in the posterior with maximum posterior log density.  Here, the Jacobian adjustment for the constraining transform to x is included as part of the definition of $p(x \mid y)$.</span>
<span id="cb38-719"><a href="#cb38-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-720"><a href="#cb38-720" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-721"><a href="#cb38-721" aria-hidden="true" tabindex="-1"></a>x^{**} = \textrm{arg max}_x \log p(x \mid y).</span>
<span id="cb38-722"><a href="#cb38-722" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-723"><a href="#cb38-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-724"><a href="#cb38-724" aria-hidden="true" tabindex="-1"></a>The maximum a posteriori (MAP) estimate can be calculated with optimization in Stan by turning on the Jacobian adjustment for constrained parameters.</span>
<span id="cb38-725"><a href="#cb38-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-728"><a href="#cb38-728" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-729"><a href="#cb38-729" aria-hidden="true" tabindex="-1"></a>fit_map <span class="op">=</span> model.optimize(data <span class="op">=</span> data, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">True</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb38-730"><a href="#cb38-730" aria-hidden="true" tabindex="-1"></a>X_hat_map <span class="op">=</span> fit_map.stan_variable(<span class="st">'X'</span>)</span>
<span id="cb38-731"><a href="#cb38-731" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-732"><a href="#cb38-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-733"><a href="#cb38-733" aria-hidden="true" tabindex="-1"></a><span class="fu">### MLE and MAP for unconstrained model</span></span>
<span id="cb38-734"><a href="#cb38-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-735"><a href="#cb38-735" aria-hidden="true" tabindex="-1"></a>The third estimation strategy involves the direct unconstrained parameterization with an ICAR prior on the unconstrained parameters.  Because there are no constraining transforms, the penalized MLE and MAP estimates coincide.  These can be computed in Stan as follows.</span>
<span id="cb38-736"><a href="#cb38-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-739"><a href="#cb38-739" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-740"><a href="#cb38-740" aria-hidden="true" tabindex="-1"></a>sigma_unc <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb38-741"><a href="#cb38-741" aria-hidden="true" tabindex="-1"></a>data_unc <span class="op">=</span> {</span>
<span id="cb38-742"><a href="#cb38-742" aria-hidden="true" tabindex="-1"></a>    <span class="st">"N"</span>: N, <span class="st">"R"</span>: R, <span class="st">"d"</span>: N, <span class="st">"M1"</span>: M1, <span class="st">"M2"</span>: M2, <span class="st">"r"</span>: r, <span class="st">"N_p"</span>: N_p,</span>
<span id="cb38-743"><a href="#cb38-743" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Y"</span>: Y, <span class="st">"sigma"</span>: sigma_unc</span>
<span id="cb38-744"><a href="#cb38-744" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-745"><a href="#cb38-745" aria-hidden="true" tabindex="-1"></a>fit_mle_unc <span class="op">=</span> model_unc.optimize(data <span class="op">=</span> data_unc, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">False</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb38-746"><a href="#cb38-746" aria-hidden="true" tabindex="-1"></a>X_hat_mle_unc <span class="op">=</span> fit_mle_unc.stan_variable(<span class="st">'X'</span>)</span>
<span id="cb38-747"><a href="#cb38-747" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-748"><a href="#cb38-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-749"><a href="#cb38-749" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing the optimization-based fits</span></span>
<span id="cb38-750"><a href="#cb38-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-751"><a href="#cb38-751" aria-hidden="true" tabindex="-1"></a>@fig-pointfits shows the fits for the MLE, MAP, and unconstrained MLE/MAP estimates as well as the original image from which data is simulated.</span>
<span id="cb38-752"><a href="#cb38-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-755"><a href="#cb38-755" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-756"><a href="#cb38-756" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Original image and optimization-based reconstructions. (a) original source image, (b) penalized maximum likelihood estimate, (c) maximum a posteriori estimate, (d) penalized maximum likelihood (equivalently maximum a posteriori) estimate for unconstrained model.</span></span>
<span id="cb38-757"><a href="#cb38-757" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pointfits</span></span>
<span id="cb38-758"><a href="#cb38-758" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-759"><a href="#cb38-759" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-760"><a href="#cb38-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-761"><a href="#cb38-761" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_plot(fig, m, n, k, title, x):</span>
<span id="cb38-762"><a href="#cb38-762" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(m, n, k, title<span class="op">=</span>title)</span>
<span id="cb38-763"><a href="#cb38-763" aria-hidden="true" tabindex="-1"></a>    ax.imshow(x, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb38-764"><a href="#cb38-764" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks([])</span>
<span id="cb38-765"><a href="#cb38-765" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks([])</span>
<span id="cb38-766"><a href="#cb38-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-767"><a href="#cb38-767" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb38-768"><a href="#cb38-768" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="st">"(a) source"</span>, X_src)</span>
<span id="cb38-769"><a href="#cb38-769" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="st">"(b) MLE"</span>, X_hat_mle)</span>
<span id="cb38-770"><a href="#cb38-770" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="st">"(c) MAP"</span>, X_hat_map)</span>
<span id="cb38-771"><a href="#cb38-771" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="st">"(d) MLE/MAP [unc]"</span>, X_hat_mle_unc)</span>
<span id="cb38-772"><a href="#cb38-772" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-773"><a href="#cb38-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-774"><a href="#cb38-774" aria-hidden="true" tabindex="-1"></a><span class="fu">## Effect of prior scale</span></span>
<span id="cb38-775"><a href="#cb38-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-776"><a href="#cb38-776" aria-hidden="true" tabindex="-1"></a>There is a free tuning parameter $\sigma,$ which is the prior scale.  This is input as data to the Stan program and used in the ICAR prior to smooth (i.e., regularize) the values of adjacent pixels toward each other.  The earlier example used $\sigma = 1,$ which does very little smoothing given that the range of values is 0 to 1.  A range of values for $\sigma$ can be evaluated in a loop.</span>
<span id="cb38-777"><a href="#cb38-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-780"><a href="#cb38-780" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-781"><a href="#cb38-781" aria-hidden="true" tabindex="-1"></a>sigmas <span class="op">=</span> [<span class="dv">1</span><span class="op">/</span><span class="dv">256</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">64</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">16</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">16</span>]</span>
<span id="cb38-782"><a href="#cb38-782" aria-hidden="true" tabindex="-1"></a>J <span class="op">=</span> <span class="bu">len</span>(sigmas)</span>
<span id="cb38-783"><a href="#cb38-783" aria-hidden="true" tabindex="-1"></a>X_fits <span class="op">=</span> np.ones(shape<span class="op">=</span>(J, <span class="dv">256</span>, <span class="dv">256</span>))</span>
<span id="cb38-784"><a href="#cb38-784" aria-hidden="true" tabindex="-1"></a>data_varying_sigma <span class="op">=</span> data.copy()</span>
<span id="cb38-785"><a href="#cb38-785" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, sigma <span class="kw">in</span> <span class="bu">enumerate</span>(sigmas):</span>
<span id="cb38-786"><a href="#cb38-786" aria-hidden="true" tabindex="-1"></a>    data_varying_sigma[<span class="st">'sigma'</span>] <span class="op">=</span> sigma</span>
<span id="cb38-787"><a href="#cb38-787" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> model.optimize(data <span class="op">=</span> data_varying_sigma, inits<span class="op">=</span><span class="fl">0.5</span>, jacobian<span class="op">=</span><span class="va">True</span>, seed <span class="op">=</span> <span class="dv">5678</span>)</span>
<span id="cb38-788"><a href="#cb38-788" aria-hidden="true" tabindex="-1"></a>    X_fits[j, :, :] <span class="op">=</span> fit.stan_variable(<span class="st">'X'</span>).copy()</span>
<span id="cb38-789"><a href="#cb38-789" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-790"><a href="#cb38-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-791"><a href="#cb38-791" aria-hidden="true" tabindex="-1"></a>The resulting estimates are displayed in @fig-sigmas.</span>
<span id="cb38-792"><a href="#cb38-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-795"><a href="#cb38-795" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-796"><a href="#cb38-796" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Effect of different sigma values on smoothing.</span></span>
<span id="cb38-797"><a href="#cb38-797" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-sigmas</span></span>
<span id="cb38-798"><a href="#cb38-798" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-799"><a href="#cb38-799" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: top</span></span>
<span id="cb38-800"><a href="#cb38-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-801"><a href="#cb38-801" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb38-802"><a href="#cb38-802" aria-hidden="true" tabindex="-1"></a>add_plot(fig, <span class="dv">2</span>, (J <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>, <span class="dv">1</span>, <span class="st">"source"</span>, X_src)</span>
<span id="cb38-803"><a href="#cb38-803" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, sigma <span class="kw">in</span> <span class="bu">enumerate</span>(sigmas):</span>
<span id="cb38-804"><a href="#cb38-804" aria-hidden="true" tabindex="-1"></a>    add_plot(fig, <span class="dv">2</span>, (J <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>, j <span class="op">+</span> <span class="dv">2</span>, <span class="ss">f"sigma: </span><span class="sc">{</span>sigma<span class="sc">:5.3f}</span><span class="ss">"</span>, X_fits[j])</span>
<span id="cb38-805"><a href="#cb38-805" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-806"><a href="#cb38-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-807"><a href="#cb38-807" aria-hidden="true" tabindex="-1"></a><span class="fu">## Bayesian estimates and samples</span></span>
<span id="cb38-808"><a href="#cb38-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-809"><a href="#cb38-809" aria-hidden="true" tabindex="-1"></a>We consider two Bayesian methods, both of which produce draws and allow for plug-in Monte Carlo estimation of posterior predictive quantitites.  The first is variational inference, which provide approximate posterior draws, and the second is Markov-chain Monte Carlo, which is much more expensive, but produces unbiased posterior draws.</span>
<span id="cb38-810"><a href="#cb38-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-811"><a href="#cb38-811" aria-hidden="true" tabindex="-1"></a><span class="fu">### Variational inference</span></span>
<span id="cb38-812"><a href="#cb38-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-813"><a href="#cb38-813" aria-hidden="true" tabindex="-1"></a>Variational inference fits an approximate distribution $q(x \mid \phi)$ to the target posterior density $p(x \mid y)$ by choosing the approximating parameters $\phi$ that render it closest in terms of Kullback-Leibler divergence,</span>
<span id="cb38-814"><a href="#cb38-814" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb38-815"><a href="#cb38-815" aria-hidden="true" tabindex="-1"></a>\phi^* = \textrm{arg max}_\phi \ \textrm{KL}<span class="co">[</span><span class="ot">q(x \mid \phi) || p(x \mid y)</span><span class="co">]</span>.</span>
<span id="cb38-816"><a href="#cb38-816" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb38-817"><a href="#cb38-817" aria-hidden="true" tabindex="-1"></a>In this case study, the Pathfinder approach is used <span class="co">[</span><span class="ot">@zhang2022</span><span class="co">]</span>.  Pathfinder runs quasi-Newton optimization on the target density $p(x \mid y)$ from random initializations and then uses points along the optimization trajectory as the location of second-order Taylor approximations to the target density with the low-rank plus diagonal covariance estimated by the L-BFGS optimizer.  The result is a series of multivariate normal approximations.  Each of these is evaluated for KL-divergence using Monte Carlo methods (which are stable for the KL divergence in a way they are not stable for the gradients).  This is done several times and then the normal approximations are sampled using importance resampling.  This gives us unconstrained draws, which are then constrained to give the final set of draws for the method.</span>
<span id="cb38-818"><a href="#cb38-818" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-819"><a href="#cb38-819" aria-hidden="true" tabindex="-1"></a>Pathfinder is straightforward to run.</span>
<span id="cb38-820"><a href="#cb38-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-821"><a href="#cb38-821" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-824"><a href="#cb38-824" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-825"><a href="#cb38-825" aria-hidden="true" tabindex="-1"></a><span class="co"># fit_pf = model.pathfinder(data, inits=1, max_lbfgs_iters=10,</span></span>
<span id="cb38-826"><a href="#cb38-826" aria-hidden="true" tabindex="-1"></a><span class="co">#     psis_resample=True, num_elbo_draws=10,</span></span>
<span id="cb38-827"><a href="#cb38-827" aria-hidden="true" tabindex="-1"></a><span class="co">#     num_paths=2, draws=100, num_single_draws=100,</span></span>
<span id="cb38-828"><a href="#cb38-828" aria-hidden="true" tabindex="-1"></a><span class="co">#     show_console=False, seed=5678)</span></span>
<span id="cb38-829"><a href="#cb38-829" aria-hidden="true" tabindex="-1"></a><span class="co"># draws_pf_X = fit_pf.stan_variables()['X']</span></span>
<span id="cb38-830"><a href="#cb38-830" aria-hidden="true" tabindex="-1"></a><span class="co"># X_hat_pf = np.mean(draws_pf_X, axis=0)</span></span>
<span id="cb38-831"><a href="#cb38-831" aria-hidden="true" tabindex="-1"></a><span class="co"># X_draw_pf = draws_pf_X[10, :]  # 10 is just arbitrary draw</span></span>
<span id="cb38-832"><a href="#cb38-832" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-833"><a href="#cb38-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-834"><a href="#cb38-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-835"><a href="#cb38-835" aria-hidden="true" tabindex="-1"></a><span class="fu">### Markov-chain Monte Carlo</span></span>
<span id="cb38-836"><a href="#cb38-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-837"><a href="#cb38-837" aria-hidden="true" tabindex="-1"></a>Markov-chain Monte Carlo methods run a Markov chain, which in the limit has the target density as its stationary distribution.  This allows draws from the chain to be used for plug-in Monte Carlo estimates.</span>
<span id="cb38-838"><a href="#cb38-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-839"><a href="#cb38-839" aria-hidden="true" tabindex="-1"></a>Sampling is run in the same way as Pathinder, with draws being extracted and averaged to create the estimate.</span>
<span id="cb38-840"><a href="#cb38-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-843"><a href="#cb38-843" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-844"><a href="#cb38-844" aria-hidden="true" tabindex="-1"></a><span class="co"># inits_from_pf = fit_pf.create_inits(2, seed = 5678)</span></span>
<span id="cb38-845"><a href="#cb38-845" aria-hidden="true" tabindex="-1"></a><span class="co"># fit_sample = model.sample(data, inits=inits_from_pf, chains=2, parallel_chains=2,</span></span>
<span id="cb38-846"><a href="#cb38-846" aria-hidden="true" tabindex="-1"></a><span class="co">#                           iter_warmup=20, iter_sampling=20,</span></span>
<span id="cb38-847"><a href="#cb38-847" aria-hidden="true" tabindex="-1"></a><span class="co">#                           show_console=False, show_progress=False,</span></span>
<span id="cb38-848"><a href="#cb38-848" aria-hidden="true" tabindex="-1"></a><span class="co">#                           seed = 5678, max_treedepth=5)</span></span>
<span id="cb38-849"><a href="#cb38-849" aria-hidden="true" tabindex="-1"></a><span class="co"># draws_mcmc_X = fit_sample.stan_variable('X')</span></span>
<span id="cb38-850"><a href="#cb38-850" aria-hidden="true" tabindex="-1"></a><span class="co"># X_hat_mcmc = np.mean(draws_mcmc_X, axis=0)</span></span>
<span id="cb38-851"><a href="#cb38-851" aria-hidden="true" tabindex="-1"></a><span class="co"># X_draw_mcmc = draws_mcmc_X[10, :]  # 10 is an arbitrary draw</span></span>
<span id="cb38-852"><a href="#cb38-852" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-853"><a href="#cb38-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-854"><a href="#cb38-854" aria-hidden="true" tabindex="-1"></a><span class="fu">### Plotting MCMC-derived fits</span></span>
<span id="cb38-855"><a href="#cb38-855" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-858"><a href="#cb38-858" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb38-859"><a href="#cb38-859" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Original image and Bayesian sampling-based reconstructions. (a) original source image, (b) draw from Pathfinder, (c) mean from pathfinder, (d) draw from Markov chain Monte Carlo, (e) mean from Markov chain Monte Carlo.</span></span>
<span id="cb38-860"><a href="#cb38-860" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-bayesfits</span></span>
<span id="cb38-861"><a href="#cb38-861" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb38-862"><a href="#cb38-862" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 't'</span></span>
<span id="cb38-863"><a href="#cb38-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-864"><a href="#cb38-864" aria-hidden="true" tabindex="-1"></a><span class="co"># figbayes = plt.figure()</span></span>
<span id="cb38-865"><a href="#cb38-865" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 1, "(a) source", X_src)</span></span>
<span id="cb38-866"><a href="#cb38-866" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 2, "(b) VI [draw]", X_draw_pf)</span></span>
<span id="cb38-867"><a href="#cb38-867" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 3, "(c) VI [mean]", X_hat_pf)</span></span>
<span id="cb38-868"><a href="#cb38-868" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 4, "(d) MCMC [draw]", X_draw_mcmc)</span></span>
<span id="cb38-869"><a href="#cb38-869" aria-hidden="true" tabindex="-1"></a><span class="co"># add_plot(figbayes, 1, 5, 5, "(e) MCMC [mean]", X_hat_mcmc)</span></span>
<span id="cb38-870"><a href="#cb38-870" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-871"><a href="#cb38-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-872"><a href="#cb38-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-873"><a href="#cb38-873" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb38-874"><a href="#cb38-874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-875"><a href="#cb38-875" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb38-876"><a href="#cb38-876" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb38-877"><a href="#cb38-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-878"><a href="#cb38-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-879"><a href="#cb38-879" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendicies {.unnumbered}</span></span>
<span id="cb38-880"><a href="#cb38-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-881"><a href="#cb38-881" aria-hidden="true" tabindex="-1"></a><span class="fu"># A. Stan Programs {.appendix .unnumbered}</span></span>
<span id="cb38-882"><a href="#cb38-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-883"><a href="#cb38-883" aria-hidden="true" tabindex="-1"></a><span class="fu">## A.1 Constrained parameter version {.appendix .unnumbered}</span></span>
<span id="cb38-884"><a href="#cb38-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-885"><a href="#cb38-885" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-886"><a href="#cb38-886" aria-hidden="true" tabindex="-1"></a><span class="in">{{&lt; include stan/holoCDI.stan &gt;}}</span></span>
<span id="cb38-887"><a href="#cb38-887" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb38-888"><a href="#cb38-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-889"><a href="#cb38-889" aria-hidden="true" tabindex="-1"></a><span class="fu">## A.2 Unconstrained parameter version {.appendix .unnumbered}</span></span>
<span id="cb38-890"><a href="#cb38-890" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-891"><a href="#cb38-891" aria-hidden="true" tabindex="-1"></a><span class="in">```stan</span></span>
<span id="cb38-892"><a href="#cb38-892" aria-hidden="true" tabindex="-1"></a><span class="in">{{&lt; include stan/holoCDI-unc.stan &gt;}}</span></span>
<span id="cb38-893"><a href="#cb38-893" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>